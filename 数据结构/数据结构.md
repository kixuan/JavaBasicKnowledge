## 线性表

### 1. 线性结构

1. **线性结构定义**: 线性结构是一种顺序结构，其中元素之间是一对一的关系。在线性结构中，除第一个和最后一个元素外，每个元素都有一个前驱和一个后继。
2. **表长概念**: 表长是指线性结构中元素的数量。
3. **直接前驱和直接后继**: 在线性结构中，每个元素（除第一个和最后一个）都有一个直接前驱（前一个元素）和一个直接后继（下一个元素）。
4. **基本特征**: 线性结构的基本特征是元素之间有序排列，并且每个元素最多有一个前驱和一个后继。

### 2. 线性表

1. **线性表和线性结构**: 线性表是一种特殊的线性结构，是元素的有序集合。
2. **基本运算**:
    - **求表长**: 返回线性表中元素的数量。
    - **读表元**: 访问特定位置的元素。
    - **定位（按值查找）**: 查找具有特定值的元素位置。
    - **插入**: 在指定位置插入一个元素。
    - **删除**: 移除特定位置的元素。
3. **其它运算**: 其它运算（如排序、反转等）可以通过这些基本运算实现。

### 3. 顺序表【数组】

1. **顺序表的组成和特点**:
    - 由一个连续的内存空间和一个记录长度的变量组成。
    - 容易实现随机访问。
    - 容量与表长区别：容量是指分配的存储空间大小，表长是实际存储的元素数量。
2. **顺序表的类型定义**: 通常是一个结构体，包含一个数组和一个表示长度的变量。

### 4. 顺序表上的运算

1. **插入、删除和定位算法的思想**:
    - **插入**: 在特定位置插入元素，需要移动后续元素。
    - **删除**: 移除特定位置的元素，需要移动后续元素。
    - **定位**: 遍历表直到找到目标元素。
2. **算法图示**: 通过图示可以更直观地理解这些操作对顺序表结构的影响。
3. **算法实现**:
    - 插入和删除操作中需要注意处理边界情况和保持表的完整性。

首先，我们定义一个简单的顺序表结构：

#### 定义

```cpp
#include <iostream>
using namespace std;

const int MAX_SIZE = 100;

struct SeqList {
    int data[MAX_SIZE];
    int length;
};
```

#### 求表长

```cpp
int length(const SeqList &list) {
    return list.length;
}
```

#### 获取指定位置的元素

```cpp
int getElement(const SeqList &list, int position) {
    if (position < 1 || position > list.length) {
        cout << "Invalid position." << endl;
        return -1; // 假设顺序表不包含负数，用-1表示错误
    }
    return list.data[position - 1];
}
```

#### 按值查找

```cpp
int locateElement(const SeqList &list, int element) {
    for (int i = 0; i < list.length; i++) {
        if (list.data[i] == element) {
            return i + 1; // 返回位置（非索引）
        }
    }
    return -1; // 如果未找到
}
```

#### 插入

```cpp
void insert(SeqList &list, int position, int element) {
    if (position < 1 || position > list.length + 1 || list.length == MAX_SIZE) {
        cout << "Invalid position or list is full." << endl;
        return;
    }
    for (int i = list.length; i >= position; i--) {
        list.data[i] = list.data[i - 1];
    }
    list.data[position - 1] = element;
    list.length++;
}
```

#### 删除

```cpp
void remove(SeqList &list, int position) {
    if (position < 1 || position > list.length) {
        cout << "Invalid position." << endl;
        return;
    }
    for (int i = position; i < list.length; i++) {
        list.data[i - 1] = list.data[i];
    }
    list.length--;
}
```

#### 冒泡排序

```cpp
void bubbleSort(SeqList &list) {
    for (int i = 0; i < list.length - 1; i++) {
        for (int j = 0; j < list.length - i - 1; j++) {
            if (list.data[j] > list.data[j + 1]) {
                swap(list.data[j], list.data[j + 1]);
            }
        }
    }
}
```

#### 反转

```cpp
void reverse(SeqList &list) {
    int start = 0;
    int end = list.length - 1;
    while (start < end) {
        swap(list.data[start], list.data[end]);
        start++;
        end--;
    }
}
```

### 5. 单链表

1. **单链表的定义和特点**:
    - 每个节点包含数据和指向下一个节点的指针。
    - 适用于元素数量不定或频繁插入和删除的场景。
2. **节点结构和类型定义**:
    - 通常定义为一个包含数据和指针的结构体。
3. **头指针和头结点的区别**: 头指针是指向链表第一个节点的指针，而头结点是一个额外的、不存储实际数据的首节点，可以简化某些操作。
4. **单链表的绘制**: 用图示法表示单链表的结构。

### 6. 单链表上的运算

1. **算法的基本思想**:
    - 插入、删除、定位运算涉及指针操作和节点间关系的调整。
2. **插入和删除中的指针操作**:
    - 需要正确处理指针以维护链表的结构。

#### 起始定义

```cpp
truct ListNode {
    int data;
    ListNode* next;
    // 构造函数简化书写，x初始化data，nullptr初始化next
    ListNode(int x) : data(x), next(nullptr) {}
};
// 创建一个新的链表节点
ListNode* createNode(int value) {
    return new ListNode(value);
}
```

#### 求表长

```cpp
int length(ListNode* head) {
    int count = 0;
    ListNode* current = head;
    while (current != nullptr) {
        count++;
        current = current->next;
    }
    return count;
}
```

#### 按值查找

```cpp
ListNode* searchByValue(ListNode* head, int value) {
    ListNode* current = head;
    while (current != nullptr) {
        if (current->data == value) {
            return current;
        }
        current = current->next;
    }
    return nullptr; // 如果没有找到
}
```

#### 按序号查找

```cpp
ListNode* searchByIndex(ListNode* head, int index) {
    int count = 0;
    ListNode* current = head;
    while (current != nullptr && count < index) {
        current = current->next;
        count++;
    }
    return current; // 如果index超出链表长度，返回nullptr
}
```

#### 插入操作

```cpp
void insertAfter(ListNode* node, int element) {
    if (node == nullptr) return;
    ListNode* newNode = new ListNode(element);
    newNode->next = node->next;
    node->next = newNode;
}
```

#### 删除操作

```cpp
void deleteNode(ListNode*& head, ListNode* nodeToDelete) {
    // 处理空链表或没有指定删除的节点
    if (head == nullptr || nodeToDelete == nullptr) return;

    // 如果要删除的是头节点
    if (head == nodeToDelete) {
        ListNode* nextNode = head->next;
        delete head;  // 释放头节点
        head = nextNode;  // 更新头节点
        return;
    }

    // 查找 nodeToDelete 的前驱节点
    ListNode* current = head;
    while (current->next != nullptr && current->next != nodeToDelete) {
        current = current->next;
    }

    // 如果找到 nodeToDelete
    if (current->next == nodeToDelete) {
        current->next = nodeToDelete->next;  // 跳过 nodeToDelete
        delete nodeToDelete;  // 释放 nodeToDelete 节点
    }
}

```

#### 转链表

```cpp
ListNode* reverse(ListNode* head) {
    ListNode *prev = nullptr, *current = head, *next = nullptr;
    while (current != nullptr) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    return prev; // 新的头节点
}
```

#### 删除特定值的节点

```cpp
void deleteByValue(ListNode*& head, int value) {
    ListNode *current = head, *prev = nullptr;
    while (current != nullptr) {
        if (current->data == value) {
            if (prev == nullptr) {
                head = current->next;
            } else {
                prev->next = current->next;
            }
            delete current;
            return;
        }
        prev = current;
        current = current->next;
    }
}
```

### 7. 循环链表和双向链表

1. **循环链表**: 在循环链表中，最后一个节点指向第一个节点，形成一个闭环。
2. **双向链表**: 双向链表的每个节点都有两个指针，分别指向前一个和后一个节点。

#### 循环链表

循环链表与普通的单链表类似，不同之处在于循环链表的最后一个节点指向头节点，形成一个环。

##### 基本定义

```cpp
struct CircularListNode {
    int data;
    CircularListNode* next;

    CircularListNode(int x) : data(x), next(this) {}
};
```

##### 插入操作

在循环链表中插入节点通常包括在头部或尾部插入。这里展示在尾部插入新节点的操作：

```cpp
void insertAtEnd(CircularListNode*& head, int value) {
    CircularListNode* newNode = new CircularListNode(value);
    if (head == nullptr) {
        head = newNode;
    } else {
        CircularListNode* temp = head;
        while (temp->next != head) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->next = head;
    }
}
```

##### 删除操作

删除循环链表中的节点也需要特别处理，以下是删除头节点的示例：

```cpp
void deleteAtHead(CircularListNode*& head) {
    if (head == nullptr) return;
    if (head->next == head) {
        delete head;
        head = nullptr;
    } else {
        CircularListNode* temp = head;
        while (temp->next != head) {
            temp = temp->next;
        }
        temp->next = head->next;
        delete head;
        head = temp->next;
    }
}
```

#### 双向链表

双向链表的每个节点都有两个指针，分别指向前一个节点和后一个节点。

##### 基本定义

```cpp
struct DoubleListNode {
    int data;
    DoubleListNode *prev, *next;

    DoubleListNode(int x) : data(x), prev(nullptr), next(nullptr) {}
};
```

##### 插入操作

在双向链表中插入节点通常包括在头部、尾部或指定位置插入。这里展示在尾部插入新节点的操作：

```cpp
void insertAtEnd(DoubleListNode*& head, int value) {
    DoubleListNode* newNode = new DoubleListNode(value);
    if (head == nullptr) {
        head = newNode;
    } else {
        DoubleListNode* temp = head;
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->prev = temp;
    }
}
```

##### 删除操作

删除双向链表中的节点时，需要更新前驱和后继节点的指针。以下是删除指定节点的示例：

```cpp
void deleteNode(DoubleListNode*& head, DoubleListNode* nodeToDelete) {
    if (head == nullptr || nodeToDelete == nullptr) return;
    if (nodeToDelete == head) {
        head = nodeToDelete->next;
    }
    // 举例：A ↔ B ↔ C
    if (nodeToDelete->next != nullptr) {
        nodeToDelete->next->prev = nodeToDelete->prev;
    }
    if (nodeToDelete->prev != nullptr) {
        nodeToDelete->prev->next = nodeToDelete->next;
    }
    delete nodeToDelete;
}
```

### 8. 顺序表与链表的比较

1. **顺序表的优缺点**:
    - 优点：可随机访问，存储密度高。
    - 缺点：容量不易估计，插入和删除效率低。
2. **链表的优缺点**:
    - 优点：插入和删除高效，容量灵活。
    - 缺点：存储密度低，无法随机访问。

## 栈和队列

### 1. 栈（Stack）

#### 1.1 栈的逻辑结构

- 栈是一种特殊的线性结构。
- 遵循后进先出（LIFO, Last In First Out）原则。

#### 1.2 基本运算和特点

- **基本操作**：进栈（push）、退栈（pop）、查看栈顶（peek）。
- **特点**：只在栈顶添加或删除元素，不允许在其他位置进行操作。
- **与线性表的异同**：栈是受限的线性表，只允许在一端进行操作。

#### 1.3 简单应用

- 应用示例：括号匹配、逆波兰表达式（后缀表达式）计算等。

#### 2.1 顺序栈的组织和类型定义

- 使用数组实现。
- 类型定义：包含一个数组和一个指示栈顶位置的变量。
- **上溢**：尝试向已满的栈中添加元素。
- **下溢**：尝试从空栈中取出元素。

#### 2.2 顺序栈的进栈和退栈实现

- **进栈**：在栈顶添加元素。
- **退栈**：从栈顶移除元素。
- 栈满和栈空的条件检查。

顺序栈的实现：

```cpp
class ArrayStack {
private:
    int* stack;
    int maxSize;
    int top;

public:
    ArrayStack(int size) {
        maxSize = size;
        stack = new int[maxSize];
        top = -1;
    }

    ~ArrayStack() {
        delete[] stack;
    }

    void push(int value) {
        if (top >= maxSize - 1) {// 栈上溢
            return;
        }
        stack[++top] = value;
    }

    int pop() {
        if (top < 0) {// 栈下溢
            return INT_MIN;
        }
        return stack[top--];
    }

    int peek() {
        if (top < 0) {
            return INT_MIN;
        }
        return stack[top];
    }

    bool isEmpty() {
        return top < 0;
    }
};

```

#### 2.3 顺序栈上的算法设计

#### 示例1: 括号匹配检查

```c++
bool areBracketsBalanced(string expr) {
    stack<char> stack;

    for (char ch : expr) {
        if (ch == '(' || ch == '[' || ch == '{') {
            // 如果是左括号，推入栈中
            stack.push(ch);
        } else {
            // 如果是右括号，检查栈顶元素
            if (stack.empty()) return false;

            char top = stack.top();
            if ((ch == ')' && top != '(') ||
                (ch == ']' && top != '[') ||
                (ch == '}' && top != '{')) {
                return false;
            }

            stack.pop(); // 匹配则弹出栈顶元素
        }
    }

    return stack.empty(); // 检查栈是否为空
}
```

示例2: 中缀表达式转后缀表达式

```c++
int getPrecedence(char ch) {
    if (ch == '+' || ch == '-') return 1;
    if (ch == '*' || ch == '/') return 2;
    return 0;
}

string infixToPostfix(string infix) {
    stack<char> stack;
    string postfix;

    for (char ch : infix) {
        if (isalnum(ch)) {
            postfix += ch;
        } else if (ch == '(') {
            stack.push(ch);
        } else if (ch == ')') {
            while (!stack.empty() && stack.top() != '(') {
                postfix += stack.top();
                stack.pop();
            }
            stack.pop(); // Pop the '('
        } else {
            while (!stack.empty() && getPrecedence(ch) <= getPrecedence(stack.top())) {
                postfix += stack.top();
                stack.pop();
            }
            stack.push(ch);
        }
    }

    while (!stack.empty()) {
        postfix += stack.top();
        stack.pop();
    }

    return postfix;
}

```

#### 3. 栈的链接实现

- 使用链表实现。
- **节点形式**：每个节点包含数据和指向下一个节点的指针。
- **链栈组织方法**：头部作为栈顶。

#### 3.2 链栈的进栈和退栈算法

- **进栈**：在链表头部添加节点。
- **退栈**：从链表头部移除节点。

```c++
struct ListNode {
    int data;
    ListNode* next;

    ListNode(int x) : data(x), next(nullptr) {}
};

class LinkedStack {
private:
    ListNode* top;

public:
    LinkedStack() {
        top = nullptr;
    }

    ~LinkedStack() {
        while (!isEmpty()) {
            pop();
        }
    }

    void push(int value) {
        ListNode* newNode = new ListNode(value);
        newNode->next = top;
        top = newNode;
    }

    int pop() {
        if (top == nullptr) {
            return INT_MIN;
        }
        ListNode* temp = top;
        int value = top->data;
        top = top->next;
        delete temp;
        return value;
    }

    int peek() {
        if (top == nullptr) {
            return INT_MIN;
        }
        return top->data;
    }

    bool isEmpty() {
        return top == nullptr;
    }
};

```

#### 3.4 顺序栈与链栈的区别

- **顺序栈**：固定大小，快速访问，空间效率可能低。
- **链栈**：动态大小，稍慢的访问，更高的空间效率。

### 4. 队列（Queue）

#### 4.1 队列的逻辑结构

- 队列是一种线性结构。
- 遵循先进先出（FIFO, First In First Out）原则。

#### 4.2 队列的基本运算和特点

- **基本操作**：入队（enqueue）、出队（dequeue）、查看队首（front）。
- **特点**：在队尾添加元素，在队首删除元素。

#### 4.3 队列与栈的异同

- **相同**：都是线性结构。
- **不同**：栈是 LIFO，队列是 FIFO。

#### 4.4 队列与线性表的异同

- **相同**：都是线性结构。
- **不同**：队列操作受限于两端，线性表可在任意位置操作。

#### 5.1 顺序队列的组织和“假溢出”

- 使用数组实现。
- **假溢出**：尽管数组中还有空间，但无法在队尾添加新元素。为了区分队空和队满的情况
    - **队列为空**的条件是 `front == rear`。
    - **队列为满**的条件是 `(rear + 1) % maxSize == front`。

#### 5.2 循环队列的组织

- 使用循环数组避免假溢出。
- 循环队列的入队和出队操作。
- 队满和队空的条件。

<img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231207090024083.png" alt="image-20231207090024083" style="zoom:150%;" />

```c++
class ArrayQueue {
private:
    int* queue;
    int maxSize;
    // front 第一个元素
    // rear 队列中最后一个元素的下一个位置。这是新元素将要被入队的位置
    int front, rear;

public:
    ArrayQueue(int size) {
        maxSize = size;
        queue = new int[maxSize];
        front = 0;
        rear = 0;
    }

    ~ArrayQueue() {
        delete[] queue;
    }

    void enqueue(int value) {
        if ((rear + 1) % maxSize == front) {// 队满
            return;
        }
        queue[rear] = value;
        rear = (rear + 1) % maxSize;
    }

    int dequeue() {
        if (front == rear) { // 队空
            return INT_MIN;
        }
        int value = queue[front];
        front = (front + 1) % maxSize;
        return value;
    }

    int peek() {
        if (front == rear) {
            return INT_MIN;
        }
        return queue[front];
    }

    bool isEmpty() {
        return front == rear;
    }
};

```

#### 6.1 链队的组织和类型定义

- 使用链表实现。
- **节点形式**：每个节点包含数据和指向下一个节点的指针。
- **链队组织方法**：队首和队尾指针。

#### 6.2 链队的入队和出队算法

- **入队**：在链表尾部添加节点。
- **出队**：从链表头部移除节点。

```c++
class LinkedQueue {
private:
    ListNode *front, *rear;

public:
    LinkedQueue() {
        front = nullptr;
        rear = nullptr;
    }

    ~LinkedQueue() {
        while (!isEmpty()) {
            dequeue();
        }
    }

    void enqueue(int value) {
        ListNode* newNode = new ListNode(value);
        if (rear == nullptr) {
            front = rear = newNode;
            return;
        }
        rear->next = newNode;
        rear = newNode;
    }

    int dequeue() {
        if (front == nullptr) {
            return INT_MIN;
        }
        ListNode* temp = front;
        int value = front->data;
        front = front->next;
        if (front == nullptr) {
            rear = nullptr;
        }
        delete temp;
        return value;
    }

    int peek() {
        if (front == nullptr) {
            return INT_MIN;
        }
        return front->data;
    }

    bool isEmpty() {
        return front == nullptr;
    }
};

```

#### 6.3 链队上算法的设计

示例: 队列应用 - 任务调度

```c++
class TaskScheduler {
private:
    queue<int> taskQueue;

public:
    void addTask(int taskId) {
        taskQueue.push(taskId);
    }

    void executeTasks() {
        while (!taskQueue.empty()) {
            int taskId = taskQueue.front();
            taskQueue.pop();

            // 执行任务
            cout << "Executing task " << taskId << endl;
        }
    }
};

```

#### 示例2: 翻转队列

```c++
void reverseQueue(LinkedQueue &queue) {
    stack<int> stack;
    
    // 将队列元素移到栈中
    while (!queue.isEmpty()) {
        stack.push(queue.dequeue());
    }

    // 再次将元素从栈移回队列
    while (!stack.empty()) {
        queue.enqueue(stack.top());
        stack.pop();
    }
}
```

### 7. 递归算法的思想及设计方法

- 递归是一种通过函数自己调用自己来解决问题的方法。
- 递归算法通常包括基本情况（递归终止条件）和递归步骤。
- 递归应用示例：阶乘计算、斐波那契数列、树的遍历等。