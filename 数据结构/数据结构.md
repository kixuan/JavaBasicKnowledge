## 线性表

### 1. 线性结构

1. **线性结构定义**: 线性结构是一种顺序结构，其中元素之间是一对一的关系。在线性结构中，除第一个和最后一个元素外，每个元素都有一个前驱和一个后继。
2. **表长概念**: 表长是指线性结构中元素的数量。
3. **直接前驱和直接后继**: 在线性结构中，每个元素（除第一个和最后一个）都有一个直接前驱（前一个元素）和一个直接后继（下一个元素）。
4. **基本特征**: 线性结构的基本特征是元素之间有序排列，并且每个元素最多有一个前驱和一个后继。

### 2. 线性表

1. **线性表和线性结构**: 线性表是一种特殊的线性结构，是元素的有序集合。
2. **基本运算**:
   - **求表长**: 返回线性表中元素的数量。
   - **读表元**: 访问特定位置的元素。
   - **定位（按值查找）**: 查找具有特定值的元素位置。
   - **插入**: 在指定位置插入一个元素。
   - **删除**: 移除特定位置的元素。
3. **其它运算**: 其它运算（如排序、反转等）可以通过这些基本运算实现。

### 3. 顺序表【数组】

1. **顺序表的组成和特点**:
   - 由一个连续的内存空间和一个记录长度的变量组成。
   - 容易实现随机访问。
   - 容量与表长区别：容量是指分配的存储空间大小，表长是实际存储的元素数量。
2. **顺序表的类型定义**: 通常是一个结构体，包含一个数组和一个表示长度的变量。

### 4. 顺序表上的运算

1. **插入、删除和定位算法的思想**:
   - **插入**: 在特定位置插入元素，需要移动后续元素。
   - **删除**: 移除特定位置的元素，需要移动后续元素。
   - **定位**: 遍历表直到找到目标元素。
2. **算法图示**: 通过图示可以更直观地理解这些操作对顺序表结构的影响。
3. **算法实现**:
   - 插入和删除操作中需要注意处理边界情况和保持表的完整性。

首先，我们定义一个简单的顺序表结构：

#### 定义

```cpp
#include <iostream>
using namespace std;

const int MAX_SIZE = 100;

struct SeqList {
    int data[MAX_SIZE];
    int length;
};
```

#### 求表长

```cpp
int length(const SeqList &list) {
    return list.length;
}
```

#### 获取指定位置的元素

```cpp
int getElement(const SeqList &list, int position) {
    if (position < 1 || position > list.length) {
        cout << "Invalid position." << endl;
        return -1; // 假设顺序表不包含负数，用-1表示错误
    }
    return list.data[position - 1];
}
```

#### 按值查找

```cpp
int locateElement(const SeqList &list, int element) {
    for (int i = 0; i < list.length; i++) {
        if (list.data[i] == element) {
            return i + 1; // 返回位置（非索引）
        }
    }
    return -1; // 如果未找到
}
```

#### 插入

```cpp
void insert(SeqList &list, int position, int element) {
    if (position < 1 || position > list.length + 1 || list.length == MAX_SIZE) {
        cout << "Invalid position or list is full." << endl;
        return;
    }
    for (int i = list.length; i >= position; i--) {
        list.data[i] = list.data[i - 1];
    }
    list.data[position - 1] = element;
    list.length++;
}
```

#### 删除

```cpp
void remove(SeqList &list, int position) {
    if (position < 1 || position > list.length) {
        cout << "Invalid position." << endl;
        return;
    }
    for (int i = position; i < list.length; i++) {
        list.data[i - 1] = list.data[i];
    }
    list.length--;
}
```

#### 冒泡排序

```cpp
void bubbleSort(SeqList &list) {
    for (int i = 0; i < list.length - 1; i++) {
        for (int j = 0; j < list.length - i - 1; j++) {
            if (list.data[j] > list.data[j + 1]) {
                swap(list.data[j], list.data[j + 1]);
            }
        }
    }
}
```

#### 反转

```cpp
void reverse(SeqList &list) {
    int start = 0;
    int end = list.length - 1;
    while (start < end) {
        swap(list.data[start], list.data[end]);
        start++;
        end--;
    }
}
```

### 5. 单链表

1. **单链表的定义和特点**:
   - 每个节点包含数据和指向下一个节点的指针。
   - 适用于元素数量不定或频繁插入和删除的场景。
2. **节点结构和类型定义**:
   - 通常定义为一个包含数据和指针的结构体。
3. **头指针和头结点的区别**: 头指针是指向链表第一个节点的指针，而头结点是一个额外的、不存储实际数据的首节点，可以简化某些操作。
4. **单链表的绘制**: 用图示法表示单链表的结构。

### 6. 单链表上的运算

1. **算法的基本思想**:
   - 插入、删除、定位运算涉及指针操作和节点间关系的调整。
2. **插入和删除中的指针操作**:
   - 需要正确处理指针以维护链表的结构。

#### 起始定义

```cpp
truct ListNode {
    int data;
    ListNode* next;
    // 构造函数简化书写，x初始化data，nullptr初始化next
    ListNode(int x) : data(x), next(nullptr) {}
};
// 创建一个新的链表节点
ListNode* createNode(int value) {
    return new ListNode(value);
}
```

#### 求表长

```cpp
int length(ListNode* head) {
    int count = 0;
    ListNode* current = head;
    while (current != nullptr) {
        count++;
        current = current->next;
    }
    return count;
}
```

#### 按值查找

```cpp
ListNode* searchByValue(ListNode* head, int value) {
    ListNode* current = head;
    while (current != nullptr) {
        if (current->data == value) {
            return current;
        }
        current = current->next;
    }
    return nullptr; // 如果没有找到
}
```

#### 按序号查找

```cpp
ListNode* searchByIndex(ListNode* head, int index) {
    int count = 0;
    ListNode* current = head;
    while (current != nullptr && count < index) {
        current = current->next;
        count++;
    }
    return current; // 如果index超出链表长度，返回nullptr
}
```

#### 插入操作

```cpp
void insertAfter(ListNode* node, int element) {
    if (node == nullptr) return;
    ListNode* newNode = new ListNode(element);
    newNode->next = node->next;
    node->next = newNode;
}
```

#### 删除操作

```cpp
void deleteNode(ListNode*& head, ListNode* nodeToDelete) {
    // 处理空链表或没有指定删除的节点
    if (head == nullptr || nodeToDelete == nullptr) return;

    // 如果要删除的是头节点
    if (head == nodeToDelete) {
        ListNode* nextNode = head->next;
        delete head;  // 释放头节点
        head = nextNode;  // 更新头节点
        return;
    }

    // 查找 nodeToDelete 的前驱节点
    ListNode* current = head;
    while (current->next != nullptr && current->next != nodeToDelete) {
        current = current->next;
    }

    // 如果找到 nodeToDelete
    if (current->next == nodeToDelete) {
        current->next = nodeToDelete->next;  // 跳过 nodeToDelete
        delete nodeToDelete;  // 释放 nodeToDelete 节点
    }
}

```

#### 转链表

```cpp
ListNode* reverse(ListNode* head) {
    ListNode *prev = nullptr, *current = head, *next = nullptr;
    while (current != nullptr) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    return prev; // 新的头节点
}
```

#### 删除特定值的节点

```cpp
void deleteByValue(ListNode*& head, int value) {
    ListNode *current = head, *prev = nullptr;
    while (current != nullptr) {
        if (current->data == value) {
            if (prev == nullptr) {
                head = current->next;
            } else {
                prev->next = current->next;
            }
            delete current;
            return;
        }
        prev = current;
        current = current->next;
    }
}
```


### 7. 循环链表和双向链表

1. **循环链表**: 在循环链表中，最后一个节点指向第一个节点，形成一个闭环。
2. **双向链表**: 双向链表的每个节点都有两个指针，分别指向前一个和后一个节点。

#### 循环链表

循环链表与普通的单链表类似，不同之处在于循环链表的最后一个节点指向头节点，形成一个环。

##### 基本定义

```cpp
struct CircularListNode {
    int data;
    CircularListNode* next;

    CircularListNode(int x) : data(x), next(this) {}
};
```

##### 插入操作

在循环链表中插入节点通常包括在头部或尾部插入。这里展示在尾部插入新节点的操作：

```cpp
void insertAtEnd(CircularListNode*& head, int value) {
    CircularListNode* newNode = new CircularListNode(value);
    if (head == nullptr) {
        head = newNode;
    } else {
        CircularListNode* temp = head;
        while (temp->next != head) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->next = head;
    }
}
```

##### 删除操作

删除循环链表中的节点也需要特别处理，以下是删除头节点的示例：

```cpp
void deleteAtHead(CircularListNode*& head) {
    if (head == nullptr) return;
    if (head->next == head) {
        delete head;
        head = nullptr;
    } else {
        CircularListNode* temp = head;
        while (temp->next != head) {
            temp = temp->next;
        }
        temp->next = head->next;
        delete head;
        head = temp->next;
    }
}
```

#### 双向链表

双向链表的每个节点都有两个指针，分别指向前一个节点和后一个节点。

##### 基本定义

```cpp
struct DoubleListNode {
    int data;
    DoubleListNode *prev, *next;

    DoubleListNode(int x) : data(x), prev(nullptr), next(nullptr) {}
};
```

##### 插入操作

在双向链表中插入节点通常包括在头部、尾部或指定位置插入。这里展示在尾部插入新节点的操作：

```cpp
void insertAtEnd(DoubleListNode*& head, int value) {
    DoubleListNode* newNode = new DoubleListNode(value);
    if (head == nullptr) {
        head = newNode;
    } else {
        DoubleListNode* temp = head;
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->prev = temp;
    }
}
```

##### 删除操作

删除双向链表中的节点时，需要更新前驱和后继节点的指针。以下是删除指定节点的示例：

```cpp
void deleteNode(DoubleListNode*& head, DoubleListNode* nodeToDelete) {
    if (head == nullptr || nodeToDelete == nullptr) return;
    if (nodeToDelete == head) {
        head = nodeToDelete->next;
    }
    // 举例：A ↔ B ↔ C
    if (nodeToDelete->next != nullptr) {
        nodeToDelete->next->prev = nodeToDelete->prev;
    }
    if (nodeToDelete->prev != nullptr) {
        nodeToDelete->prev->next = nodeToDelete->next;
    }
    delete nodeToDelete;
}
```

### 8. 顺序表与链表的比较

1. **顺序表的优缺点**:
   - 优点：可随机访问，存储密度高。
   - 缺点：容量不易估计，插入和删除效率低。
2. **链表的优缺点**:
   - 优点：插入和删除高效，容量灵活。
   - 缺点：存储密度低，无法随机访问。

## 栈和队列

### 1. 栈（Stack）

#### 1.1 栈的逻辑结构

- 栈是一种特殊的线性结构。
- 遵循后进先出（LIFO, Last In First Out）原则。

#### 1.2 基本运算和特点

- **基本操作**：进栈（push）、退栈（pop）、查看栈顶（peek）。
- **特点**：只在栈顶添加或删除元素，不允许在其他位置进行操作。
- **与线性表的异同**：栈是受限的线性表，只允许在一端进行操作。

#### 1.3 简单应用

- 应用示例：括号匹配、逆波兰表达式（后缀表达式）计算等。

#### 2.1 顺序栈的组织和类型定义

- 使用数组实现。
- 类型定义：包含一个数组和一个指示栈顶位置的变量。
- **上溢**：尝试向已满的栈中添加元素。
- **下溢**：尝试从空栈中取出元素。

#### 2.2 顺序栈的进栈和退栈实现

- **进栈**：在栈顶添加元素。
- **退栈**：从栈顶移除元素。
- 栈满和栈空的条件检查。

顺序栈的实现：

```cpp
class ArrayStack {
private:
    int* stack;
    int maxSize;
    int top;

public:
    ArrayStack(int size) {
        maxSize = size;
        stack = new int[maxSize];
        top = -1;
    }

    ~ArrayStack() {
        delete[] stack;
    }

    void push(int value) {
        if (top >= maxSize - 1) {// 栈上溢
            return;
        }
        stack[++top] = value;
    }

    int pop() {
        if (top < 0) {// 栈下溢
            return INT_MIN;
        }
        return stack[top--];
    }

    int peek() {
        if (top < 0) {
            return INT_MIN;
        }
        return stack[top];
    }

    bool isEmpty() {
        return top < 0;
    }
};

```

#### 2.3 顺序栈上的算法设计

#### 示例1: 括号匹配检查

```c++
bool areBracketsBalanced(string expr) {
    stack<char> stack;

    for (char ch : expr) {
        if (ch == '(' || ch == '[' || ch == '{') {
            // 如果是左括号，推入栈中
            stack.push(ch);
        } else {
            // 如果是右括号，检查栈顶元素
            if (stack.empty()) return false;

            char top = stack.top();
            if ((ch == ')' && top != '(') ||
                (ch == ']' && top != '[') ||
                (ch == '}' && top != '{')) {
                return false;
            }

            stack.pop(); // 匹配则弹出栈顶元素
        }
    }

    return stack.empty(); // 检查栈是否为空
}
```

示例2: 中缀表达式转后缀表达式

```c++
int getPrecedence(char ch) {
    if (ch == '+' || ch == '-') return 1;
    if (ch == '*' || ch == '/') return 2;
    return 0;
}

string infixToPostfix(string infix) {
    stack<char> stack;
    string postfix;

    for (char ch : infix) {
        if (isalnum(ch)) {
            postfix += ch;
        } else if (ch == '(') {
            stack.push(ch);
        } else if (ch == ')') {
            while (!stack.empty() && stack.top() != '(') {
                postfix += stack.top();
                stack.pop();
            }
            stack.pop(); // Pop the '('
        } else {
            while (!stack.empty() && getPrecedence(ch) <= getPrecedence(stack.top())) {
                postfix += stack.top();
                stack.pop();
            }
            stack.push(ch);
        }
    }

    while (!stack.empty()) {
        postfix += stack.top();
        stack.pop();
    }

    return postfix;
}

```


#### 3. 栈的链接实现

- 使用链表实现。
- **节点形式**：每个节点包含数据和指向下一个节点的指针。
- **链栈组织方法**：头部作为栈顶。

#### 3.2 链栈的进栈和退栈算法

- **进栈**：在链表头部添加节点。
- **退栈**：从链表头部移除节点。

```c++
struct ListNode {
    int data;
    ListNode* next;

    ListNode(int x) : data(x), next(nullptr) {}
};

class LinkedStack {
private:
    ListNode* top;

public:
    LinkedStack() {
        top = nullptr;
    }

    ~LinkedStack() {
        while (!isEmpty()) {
            pop();
        }
    }

    void push(int value) {
        ListNode* newNode = new ListNode(value);
        newNode->next = top;
        top = newNode;
    }

    int pop() {
        if (top == nullptr) {
            return INT_MIN;
        }
        ListNode* temp = top;
        int value = top->data;
        top = top->next;
        delete temp;
        return value;
    }

    int peek() {
        if (top == nullptr) {
            return INT_MIN;
        }
        return top->data;
    }

    bool isEmpty() {
        return top == nullptr;
    }
};

```

#### 3.4 顺序栈与链栈的区别

- **顺序栈**：固定大小，快速访问，空间效率可能低。
- **链栈**：动态大小，稍慢的访问，更高的空间效率。

### 4. 队列（Queue）

#### 4.1 队列的逻辑结构

- 队列是一种线性结构。
- 遵循先进先出（FIFO, First In First Out）原则。

#### 4.2 队列的基本运算和特点

- **基本操作**：入队（enqueue）、出队（dequeue）、查看队首（front）。
- **特点**：在队尾添加元素，在队首删除元素。

#### 4.3 队列与栈的异同

- **相同**：都是线性结构。
- **不同**：栈是 LIFO，队列是 FIFO。

#### 4.4 队列与线性表的异同

- **相同**：都是线性结构。
- **不同**：队列操作受限于两端，线性表可在任意位置操作。

#### 5.1 顺序队列的组织和“假溢出”

- 使用数组实现。
- **假溢出**：尽管数组中还有空间，但无法在队尾添加新元素。为了区分队空和队满的情况
   - **队列为空**的条件是 `front == rear`。
   - **队列为满**的条件是 `(rear + 1) % maxSize == front`。

#### 5.2 循环队列的组织

- 使用循环数组避免假溢出。
- 循环队列的入队和出队操作。
- 队满和队空的条件。

<img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231207090024083.png" alt="image-20231207090024083" style="zoom:150%;" />

```c++
class ArrayQueue {
private:
    int* queue;
    int maxSize;
    // front 第一个元素
    // rear 队列中最后一个元素的下一个位置。这是新元素将要被入队的位置
    int front, rear;

public:
    ArrayQueue(int size) {
        maxSize = size;
        queue = new int[maxSize];
        front = 0;
        rear = 0;
    }

    ~ArrayQueue() {
        delete[] queue;
    }

    void enqueue(int value) {
        if ((rear + 1) % maxSize == front) {// 队满
            return;
        }
        queue[rear] = value;
        rear = (rear + 1) % maxSize;
    }

    int dequeue() {
        if (front == rear) { // 队空
            return INT_MIN;
        }
        int value = queue[front];
        front = (front + 1) % maxSize;
        return value;
    }

    int peek() {
        if (front == rear) {
            return INT_MIN;
        }
        return queue[front];
    }

    bool isEmpty() {
        return front == rear;
    }
};

```

#### 6.1 链队的组织和类型定义

- 使用链表实现。
- **节点形式**：每个节点包含数据和指向下一个节点的指针。
- **链队组织方法**：队首和队尾指针。

#### 6.2 链队的入队和出队算法

- **入队**：在链表尾部添加节点。
- **出队**：从链表头部移除节点。

```c++
class LinkedQueue {
private:
    ListNode *front, *rear;

public:
    LinkedQueue() {
        front = nullptr;
        rear = nullptr;
    }

    ~LinkedQueue() {
        while (!isEmpty()) {
            dequeue();
        }
    }

    void enqueue(int value) {
        ListNode* newNode = new ListNode(value);
        if (rear == nullptr) {
            front = rear = newNode;
            return;
        }
        rear->next = newNode;
        rear = newNode;
    }

    int dequeue() {
        if (front == nullptr) {
            return INT_MIN;
        }
        ListNode* temp = front;
        int value = front->data;
        front = front->next;
        if (front == nullptr) {
            rear = nullptr;
        }
        delete temp;
        return value;
    }

    int peek() {
        if (front == nullptr) {
            return INT_MIN;
        }
        return front->data;
    }

    bool isEmpty() {
        return front == nullptr;
    }
};

```

#### 6.3 链队上算法的设计

示例: 队列应用 - 任务调度

```c++
class TaskScheduler {
private:
    queue<int> taskQueue;

public:
    void addTask(int taskId) {
        taskQueue.push(taskId);
    }

    void executeTasks() {
        while (!taskQueue.empty()) {
            int taskId = taskQueue.front();
            taskQueue.pop();

            // 执行任务
            cout << "Executing task " << taskId << endl;
        }
    }
};

```

#### 示例2: 翻转队列

```c++
void reverseQueue(LinkedQueue &queue) {
    stack<int> stack;
    
    // 将队列元素移到栈中
    while (!queue.isEmpty()) {
        stack.push(queue.dequeue());
    }

    // 再次将元素从栈移回队列
    while (!stack.empty()) {
        queue.enqueue(stack.top());
        stack.pop();
    }
}
```

### 7. 递归算法的思想及设计方法

- 递归是一种通过函数自己调用自己来解决问题的方法。
- 递归算法通常包括基本情况（递归终止条件）和递归步骤。
- 递归应用示例：阶乘计算、斐波那契数列、树的遍历等。

## 树

### 1. 树结构的基本概念和术语

#### 1.1 树的定义

- 树是一种**非线性数据结构**，由**节点**（nodes）组成。
- 包括一个称为**根**（root）的节点以及零个或多个子树，这些子树也是树，并且它们的根节点被连接到根节点。

#### 1.2 树结构的术语

- **根节点（Root）**：没有父节点的节点。
- **子节点（Child）**：一个节点直接连接的节点。
- **父节点（Parent）**：有子节点的节点。
- **叶节点（Leaf）**：没有子节点的节点。
- **兄弟（Siblings）**：具有相同父节点的节点。
- **深度（Depth）**：根节点到当前节点的唯一路径上的边数。【从树底向上测量的】
- **高度（Height）**：节点到叶节点的最长路径上的边数。【从树顶向下测量的】

```mathematica
        A           <-- 根节点
       / \
      B   C
     /     \
    D       E
           / \
          F   G
```

深度：A-0，BC-1，DE-2，FG-3

高度：FGD-0，BE-1，C-2，1-3

#### 1.3 树结构的实际背景

- 用于表示具有层级关系的数据，例如文件系统、组织结构等。

### 2. 二叉树的定义和特点

#### 2.1 二叉树的逻辑结构和特点

- 每个节点最多有两个子节点：通常称为左子节点和右子节点。
- 二叉树的五种基本形态：空树、只有根节点、根节点只有左子树、根节点只有右子树、根节点有左右两个子树。

#### 2.2 二叉树的基本运算

- 插入、删除、搜索节点等。【详细代码见下面】

### 3. 二叉树的链式存储结构

#### 3.1 二叉链表的节点形式和类型定义

```c++
struct TreeNode {
    int data;
    TreeNode *left, *right;

    //构造函数
    TreeNode(int x) : data(x), left(nullptr), right(nullptr) {}
};
```

#### 3.2 二叉链表示例

```c++
// 创建示例二叉树
TreeNode* createSampleTree() {
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    return root;
}

// 一般插入
TreeNode* insert(TreeNode* root, int value) {
    if (root == nullptr) {
        return new TreeNode(value);
    }

    if (value < root->data) {
        root->left = insert(root->left, value);
    } else if (value > root->data) {
        root->right = insert(root->right, value);
    }

    return root;
}

// TODO:特定位置插入
void insertAtSpecificPosition(TreeNode* parent, int value, bool insertLeft) {
    TreeNode* newNode = new TreeNode(value);

    if (insertLeft) {
        // 检查左子节点是否为空
        if (parent->left == nullptr) {
            parent->left = newNode;
        } else {
            // 已存在左子节点，可以根据需要处理这种情况
            // 例如，可以替换或者不进行插入
        }
    } else {
        // 检查右子节点是否为空
        if (parent->right == nullptr) {
            parent->right = newNode;
        } else {
            // 已存在右子节点，可以根据需要处理这种情况
        }
    }
}


// 查找【普通二叉树，而不是二叉搜索树】
TreeNode* search(TreeNode* root, int value) {
    if (root == nullptr || root->data == value) {
        return root;
    }
    // 遍历递归左子树
    TreeNode* leftSearch = search(root->left, value);
    if (leftSearch != nullptr) {
        return leftSearch;
    }
    // 遍历递归右子树
    return search(root->right, value);
}

// 查找【二叉搜索树】
TreeNode* search(TreeNode*root ,int data){
    if(root==nullptr||root->data==data) return root;
    if(data<root->data) return search(root->left,data);
    if(data>root->data) return search(root->right,data);
}

// 更新节点
void updateNode(TreeNode* root, int oldValue, int newValue) {
    if (root == nullptr) return;
    if (root->data == oldValue) {
        root->data = newValue;
        return;
    }
    updateNode(root->left, oldValue, newValue);
    updateNode(root->right, oldValue, newValue);
}

// 删除节点
// 传入指针引用（好古老的知识点：适用于需要在函数内部管理内存（如分配或释放内存）并希望这些改变反映到原始指针上的场景。
// 直接传入指针：适用于只需要操作指针指向的数据，而不需要改变指针本身的场景，像更新的话就是只更新指向的数据
void deleteNode(TreeNode *& root,int data){
    if(root == nullptr) return root;
    if(data<root->data) deleteNode(root->left,data);
    else if(data>root->data) deleteNode(root->right,data);
    // 找到删除节点
    else {
        // 有两个节点的情况
        if(root->left!=nullptr&&root->right!=nullptr){
            // 找到右子树最左边的节点，这个节点是比root大的最小值，把这个节点替换root可以保持二叉搜索树的特性
            TreeNode* minNode = minValueNode(root->right);
            // 将找到节点の值赋给root
            root->data = minNode->data;
            // 删除这个节点，也就是原来的最小值节点的位置
            // 相当于再进一次“没有子节点”或“只有一个子节点”的删除情况，使得删除操作相对简单
            deleteNode(root->right,minNode->data);
        }else{
            TreeNode*temp = root->left?root->left:root->right;
            // 没有子节点的情况
            if(temp == nullptr){
                delete root;
                // 防止产生悬挂指针（dangling pointer），即一个仍然指向已经释放内存的指针。悬挂指针可能导致未定义的行为，包括程序崩溃和数据损坏
                root = nullptr;
            } else {
                // 只有一个子节点的情况，直接将root设为子节点的值然后删掉子节点
                // *表示解引用，就是root和temp其实都是指针，如果直接root = temp的话只是将root指向temp指向的TreeNODE，并不是真正的改变TreeNODE对象
                // 所以这里要解引用相等，直接让两个TreeNODE对象相等
                // 那又有个问题了，为什么不直接用对象而是用指针？
                // 1. 指针可以灵活动态创建和销毁节点 2.效率高，内存占用小 3.可以实现多个节点共享对同一个节点的引用
                 *root = *temp;
            }
            delete temp;
        }
    }
}

// 删除节点辅助函数，找到以root为根的树中的最小值节点
TreeNode* minValueNode(TreeNode* root) {
    TreeNode* current = root;
    while (current && current->left != nullptr) {
        current = current->left;
    }
    return current;
}

// 遍历-中序遍历
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    inorderTraversal(root->left);
    cout << root->data << " ";
    inorderTraversal(root->right);
}

```

#### 3.3 三叉链表的结点形式和组织方法

​ 类似于二叉链表，但每个节点还有一个指向父节点的指针。特别有助于在树中向上遍历，即从某个节点回到其父节点，而在普通的二叉树链表中，这通常是不可能的。

```c++
struct TriNode {
    int data;
    TriNode *left;
    TriNode *right;
    TriNode *parent;

    TriNode(int value) : data(value), left(nullptr), right(nullptr), parent(nullptr) {}
};

```

### 4. 二叉树的顺序存储结构

#### 4.1 满二叉树和完全二叉树

- **满二叉树**：所有层都完全填满，没有任何空缺。
- **完全二叉树**：除最后一层外，每层都是满的，并且最后一层的节点一定是靠左排列的。

#### 4.2 顺序存储的基本思想

- 通常使用数组来表示二叉树，特别适用于完全二叉树。
- 每个节点的位置可以根据其在树中的层次和顺序计算出来。

```c++
// TODO：只要求识记代码看看就行
// 定义
const int MAX_SIZE = 100;

struct BinaryTree {
    int nodes[MAX_SIZE];
    int size;

    BinaryTree() : size(0) {
        for (int i = 0; i < MAX_SIZE; i++) 
            nodes[i] = INT_MIN; // 使用特殊值表示空节点
    }
};

// 插入
void insert(BinaryTree &tree, int value) {
    if (tree.size >= MAX_SIZE) {
        // 树已满
        return;
    }
    tree.nodes[tree.size++] = value;
}

// 查找
int getNode(const BinaryTree &tree, int index) {
    if (index < 0 || index >= tree.size) {
        return INT_MIN; // 表示无效索引
    }
    return tree.nodes[index];
}

//遍历
void levelOrderTraversal(const BinaryTree &tree) {
    for (int i = 0; i < tree.size; i++) {
        if (tree.nodes[i] != INT_MIN) {
            cout << tree.nodes[i] << " ";
        }
    }
}

```

#### 4.3 父子节点编号关系

- 在数组中，如果根节点的索引是0，位置 `i` 的节点的左子节点是 `2*i + 1`，右子节点是 `2*i + 2`，父节点是 `(i-1)/2`。
- 如果根节点的索引是1，位置 `i` 的节点的左子节点是 `2*i`，右子节点是 `2*i + 1`，父节点是 `i/2`。

### 5. 二叉树的遍历

#### 5.1 遍历方法

- **前序遍历（Pre-order）**：中 - 左 - 右
- **中序遍历（In-order）**：左 - 中 - 右
- **后序遍历（Post-order）**：左 - 右 - 中
- **层次遍历（Level-order）**：逐层从左到右访问每个节点

举例：

```mathematica
        A
       / \
      B   C
     / \   \
    D   E   F
```

前序遍历：访问根节点->左子树->右子树。遍历的顺序是：ABDECF

中序遍历：访问左子树->根节点->右子树。遍历的顺序是：DBEACF

后序遍历：访问左子树->右子树->根节点。遍历的顺序是：DEBFCA

层次遍历：遍历的顺序是：ABCDEF

#### 5.2 遍历算法实现

**巧记：中的位置--》cout的位置--》什么序**

```c++
// 前序遍历
void preorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    cout << root->data << " ";
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}

// 中序
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    inorderTraversal(root->left);
    cout << root->data << " ";
    inorderTraversal(root->right);
}

// 后序
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    cout << root->data << " ";
}

// 层次，一般使用队列实现，广度优先搜索
void levelOrderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        //从队列中弹出第一个节点（front()）。
        //访问该节点（例如，打印节点的数据）。
		//将该节点的左右子节点（如果存在）加入队列。
        TreeNode* current = q.front();
        q.pop();
        cout << current->data << " ";

        if (current->left != nullptr) 
            q.push(current->left);
        if (current->right != nullptr)
            q.push(current->right);
    }
}

```

#### 5.3 遍历算法异同

**相同点**：所有遍历方法都是系统地访问树中的每个节点一次，但访问的顺序不同。

**不同点**：每种遍历方法侧重于不同的访问顺序，适用于不同的应用场景。

- **前序遍历**：首先访问根节点，适用于创建树的副本。
- **中序遍历**：对于二叉搜索树，可以按升序访问节点。
- **后序遍历**：首先处理子节点，适用于删除或释放节点。
- **层次遍历**：按树的层级逐层访问，适用于广度优先搜索。

#### 5.4 遍历算法实际问题的应用

1. **前序遍历应用**：
   - 树的副本创建。
   - 表达式树的操作。
   - 目录结构的遍历。
2. **中序遍历应用**：
   - 二叉搜索树的有序遍历。
   - 表达式树的中缀表示。
3. **后序遍历应用**：
   - 二叉树的删除或释放。
   - 表达式树的后缀表示。
   - 用于计算给定树的各种属性（如高度、大小）。
4. **层次遍历应用**：
   - 广度优先搜索。
   - 查找最小深度。
   - 层级顺序打印。

### 6. 树和森林

#### 6.1 树的逻辑结构和运算

- 树是一种非线性数据结构，它模拟了一个层级关系（如家族树、组织结构）。
- 在树中，每个节点可以有零个或多个子节点，但只有一个父节点（除了根节点）。
- 基本运算包括添加子节点、删除子节点、遍历等。

#### 6.2 树、森林与二叉树的转换

- 任何一棵树都可以转换为一棵二叉树，其中每个节点的左子节点是其第一个子节点，右子节点是其下一个兄弟节点。
- 森林（多棵树的集合）可以转换为一棵二叉树，其中每棵树转换为二叉树后，第一棵树的根是二叉树的根，其余树的根是前一棵树根的右子节点。

#### 6.3 树的存储结构

- 链式存储结构、顺序存储结构、索引存储结构等。【后面两种用的都是数组，可以直接根据索引找到位置，适用于完全二叉树，几乎没有内存空间被浪费，但如果是普通的二叉树的话就会有空间被浪费】

### 7. 树的应用

#### 7.1 判定树和哈夫曼树

- **判定树**：用于决策和分类。
- **哈夫曼树（Huffman Tree）**：用于数据压缩。

#### 7.2 哈夫曼树构造算法

**概念和背景**

- 哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。
- 用于数据压缩（如哈夫曼编码），在编码中频率高的字符使用较短的编码，频率低的使用较长的编码。

**构造算法**

1. **统计频率**：
   - 对每个字符及其出现的频率进行统计。
   - 将每个字符视作一个节点，并根据频率为这些节点赋予权重。
2. **初始化优先队列**：
   - 创建一个优先队列（或最小堆），并将所有节点插入队列中。
   - 优先队列按照节点的权重（频率）排序。
3. **构建树**：
   - 只要优先队列中的节点数量大于1，执行以下步骤：
      - 从队列中弹出两个频率最低的节点（权重最小的节点）。
      - 创建一个新节点作为这两个节点的父节点，其频率是这两个节点频率的和。
      - 将新节点插入优先队列。
4. **完成构造**：
   - 当优先队列只剩下一个节点时，这个节点就是哈夫曼树的根节点，此时树的构造完成。
5. **生成哈夫曼编码**：
   - 从根节点开始，遍历树的每个叶节点。
   - 每向左走一步，添加一个“0”到编码中；每向右走一步，添加一个“1”。
   - 到达叶节点时，得到的编码即为该节点（字符）的哈夫曼编码。

假设有一组字符及其频率如下：

```
字符：a,  b,  c,  d
频率：45, 13, 12, 16
```

按照哈夫曼树构造算法：

1. 初始化优先队列，包含所有字符及其频率。
2. 首先合并频率最低的两个节点，比如 `b` 和 `c`（频率分别为 13 和 12），创建一个新节点，其频率为 25（13 + 12）。
3. 将新节点（频率为 25）放回优先队列。
4. 继续这个过程，直到优先队列中只剩下一个节点。

#### 7.3 哈夫曼树的应用

- 哈夫曼树被用于构建高效的压缩算法和数据编码系统。
- 在通信系统中用于数据传输的优化。

```c++
// 定义哈夫曼树的节点
struct HuffmanNode {
    char data;
    unsigned freq;  // 字符频率之和
    HuffmanNode *left, *right;

    HuffmanNode(char data, unsigned freq) {
        left = right = nullptr;
        this->data = data;
        this->freq = freq;
    }
    // HuffmanNode(char data, unsigned freq) : data(data), freq(freq), left(nullptr), right(nullptr) {}

};

// 用于优先级队列（小顶堆）的比较函数，比较频率，确保每次从堆中取出的两个节点是频率最低的；
struct compare {
    // 重载operator方法
    bool operator()(HuffmanNode* l, HuffmanNode* r) {
        return (l->freq > r->freq);
    }
};


// 使用优先级队列（小顶堆）构建哈夫曼树
HuffmanNode* buildHuffmanTree(char data[], int freq[], int size) {
    struct compare cmp;
    // priority_queue是c++标准模板库中的一种数据结构，提供队列功能，保证队列中的元素始终是有序的
    // HuffmanNode* - 队列存储的元素类型
    // vector<HuffmanNode*> - 内部存储结构
    // compare - 提供比较逻辑的函数对象类型 - cmp
    priority_queue<HuffmanNode*, vector<HuffmanNode*>, compare> minHeap(cmp);

    for (int i = 0; i < size; ++i)
        minHeap.push(new HuffmanNode(data[i], freq[i]));

    // 构建哈夫曼树：
	// 每次从堆中取出两个频率最低的节点。
	// 创建一个新的内部节点，其频率是这两个节点频率之和。
	// 将这两个节点作为新创建的内部节点的子节点。
	// 将新节点加入到堆中。
    
    // 队列只剩下最后一个节点，这个节点就是哈夫曼树的根节点
    while (minHeap.size() != 1) {
        // 返回队列的第一个元素--》频率最小的节点
        HuffmanNode *left = minHeap.top();
        minHeap.pop();
        // 频率第二小的节点
        HuffmanNode *right = minHeap.top();
        minHeap.pop();

        // 创建一个新的内部节点，这个节点的频率为两个节点的和，left和right是top的左右子节点，使用$就是为了区分叶子节点和内部节点，下面的generateHuffmanCodes会用到
        HuffmanNode *top = new HuffmanNode('$', left->freq + right->freq);
        top->left = left;
        top->right = right;

        // 把新创建的节点放回队列
        minHeap.push(top);
    }
    return minHeap.top();
}


// 递归地生成哈夫曼编码并存储在一个哈希表中
// 编码是根据从根到叶子的路径生成的，其中向左走记录为 "0"，向右走记录为 "1"。
void generateHuffmanCodes(struct HuffmanNode* root, string str, unordered_map<char, string> &huffmanCode) {
    if (!root)
        return;

    if (root->data != '$')
        huffmanCode[root->data] = str;

    generateHuffmanCodes(root->left, str + "0", huffmanCode);
    generateHuffmanCodes(root->right, str + "1", huffmanCode);
}

// 对一个字符串进行哈夫曼编码
void printHuffmanCodes(char data[], int freq[], int size) {
    HuffmanNode* root = buildHuffmanTree(data, freq, size);
    unordered_map<char, string> huffmanCode;
    generateHuffmanCodes(root, "", huffmanCode);

    cout << "Huffman Codes are :\n";
    for (auto pair : huffmanCode) {
        cout << pair.first << ": " << pair.second << endl;
    }
}

int main() {
    char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
    int freq[] = { 5, 9, 12, 13, 16, 45 };

    int size = sizeof(arr) / sizeof(arr[0]);
    printHuffmanCodes(arr, freq, size);

    return 0;
}

```

## 图

### 1. 图的概念

#### 1.1 图的定义和术语

- **图（Graph）**: 一组顶点和连接这些顶点的边的集合。
- **顶点（Vertex）**: 图的基本元素，通常代表一个实体。
- **边（Edge）**: 连接一对顶点的线段，可以是有向的（箭头指向）或无向的（没有箭头）。
- **路径（Path）**: 顶点的一个序列，其中每对相邻的顶点都通过边连接。

#### 1.2 图与树的异同

- **相同点**：都是由节点和边组成。
- **不同点**：树是一种特殊的图，它是无环的，并且有一个特定的根节点。图可以有环，也可能没有根节点。

### 2. 图的存储结构

#### 2.1 邻接表表示法

对于每个顶点，维护一个列表，列出与其直接相连的所有顶点。这种表示法适用于稀疏图。

```c++
struct AdjListNode {
    int dest;
    AdjListNode* next;
};

struct AdjList {
    AdjListNode* head;
};

class Graph {
    int V;
    AdjList* array;

public:
    Graph(int V) {
        this->V = V;
        array = new AdjList[V];
        for (int i = 0; i < V; ++i)
            array[i].head = nullptr;
    }

    // 添加边
    void addEdge(int src, int dest) {
        AdjListNode* newNode = new AdjListNode{dest, array[src].head};
        array[src].head = newNode;
    }
};
```

#### 2.2 邻接矩阵表示法

使用一个二维数组来表示图。如果顶点 `i` 和顶点 `j` 相连，则 `matrix[i][j]` 为 `1`（或权重值），否则为 `0`。

```c++
#include <iostream>
#include <vector>
using namespace std;

class Graph {
    int V; // 顶点的数量
    vector<vector<int>> adjMatrix; // 邻接矩阵

public:
    Graph(int V) {
        this->V = V;
        adjMatrix.resize(V, vector<int>(V, 0));
    }

    // 添加边
    void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;
        adjMatrix[v][u] = 1; // 由于是无向图，所以是对称的
    }

    // 打印邻接矩阵
    void printAdjMatrix() {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    // 创建有 4 个顶点的图
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);

    cout << "The adjacency matrix of the graph:\n";
    g.printAdjMatrix();

    return 0;
}

```

#### 2.3 优缺点比较

- **邻接矩阵**：适用于密集图，易于实现，但可能浪费空间。
- **邻接表**：适用于稀疏图，空间效率更高，但实现相对复杂。

#### 2.4 无向网络的邻接矩阵建立方法和算法

无向网络可以使用邻接矩阵进行存储，其中矩阵的每个元素表示两个顶点之间的连接关系。在无向网络中，邻接矩阵是对称的。

```c++
class Graph {
    int V;
    vector<vector<int>> adjMatrix;

public:
    Graph(int V) : V(V), adjMatrix(V, vector<int>(V, 0)) {}

    void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;
        adjMatrix[v][u] = 1; // 对于无向图
    }
};

```

#### 2.5 无向图的邻接表建立方法和算法

无向图的邻接表表示每个顶点都有一个与之相关联的列表，列出了所有与该顶点直接相连的其他顶点。

```c++
struct AdjListNode {
    int dest;
    AdjListNode* next;
};

struct AdjList {
    AdjListNode* head;
};

class Graph {
    int V;
    vector<AdjList> array;

public:
    Graph(int V) : V(V), array(V) {}

    void addEdge(int src, int dest) {
        AdjListNode* newNode = new AdjListNode{dest, array[src].head};
        array[src].head = newNode;
    }
};

```

### 3. 图的遍历

#### 3.1 深度优先搜索（DFS）

DFS 使用递归或栈来实现，遵循尽可能深地搜索图的分支。

```c++
void DFSUtil(int v, bool visited[], const Graph& g) {
    visited[v] = true;
    cout << v << " ";

    AdjListNode* node = g.array[v].head;
    while (node != nullptr) {
        if (!visited[node->dest])
            DFSUtil(node->dest, visited, g);
        node = node->next;
    }
}

void DFS(const Graph& g, int start) {
    bool* visited = new bool[g.V]();
    DFSUtil(start, visited, g);
    delete[] visited;
}
```

#### 3.2 广度优先搜索（BFS）

BFS 使用**队列**来实现，遵循先访问邻近顶点的原则。

```c++
void BFS(const vector<vector<int>>& adj, int start, int V) {
    vector<bool> visited(V, false);
    queue<int> queue;

    visited[start] = true;
    queue.push(start);

    while (!queue.empty()) {
        int v = queue.front();
        cout << v << " ";
        queue.pop();

        for (int u : adj[v]) {
            if (!visited[u]) {
                visited[u] = true;
                queue.push(u);
            }
        }
    }
}
```

#### 3. 3非连通图的遍历方法

非连通图的遍历涉及对图的每个连通分量进行遍历。对于非连通图，可以使用 DFS 或 BFS 遍历每个连通分量。

```c++
void DFS(vector<vector<int>>& adjList, vector<bool>& visited, int v) {
    visited[v] = true;
    cout << v << " ";
    for (int u : adjList[v]) {
        if (!visited[u])
            DFS(adjList, visited, u);
    }
}

void traverseDisconnectedGraph(vector<vector<int>>& adjList) {
    vector<bool> visited(adjList.size(), false);
    for (int v = 0; v < adjList.size(); v++) {
        if (!visited[v]) {
            DFS(adjList, visited, v);
        }
    }
}
```

#### 3.4 深度和广度优先搜索序列

- DFS 序列：根据深度优先的方式，记录访问顶点的顺序。
- BFS 序列：根据广度优先的方式，记录访问顶点的顺序。

### 4. 最小生成树

#### 4.1 生成树和最小生成树

生成树是包含图中所有顶点的无环子图。最小生成树是权重和最小的生成树。

最小生成树（Minimum Spanning Tree, MST）是一种在图论中非常重要的概念，它在多个领域中都有应用，特别是在那些需要最小化某种成本或连接多个点的场景中。具体应用背景包括：

1. **网络设计**：如电信网络、计算机网络、交通网络设计中，需要以最小的成本连接所有的节点。
2. **城市规划**：设计道路、水管或电缆网络以连接多个地点，同时尽量减少建设成本。
3. **集群分析**：在数据科学中，MST可以用于聚类分析，找出数据点之间的关系。
4. **物理和生物学中的网络系统**：例如在生态学中，研究不同物种之间的互动网络。

#### 4.2 Prim 算法

Prim 算法从任意顶点开始，每次添加与当前生成树距离最短的边。

Prim 算法的基本思想是从一个顶点开始，逐步增加新的边和顶点到已经选择的顶点集合中，直到所有的顶点都被包含在内。在每一步中，它都会选择一条连接已选择顶点和未选择顶点的最小边。

算法步骤：

1. 初始化一个空的树结构（最初只包含一个顶点）和一个优先队列（最小堆），用于存放与已选择顶点相连的边。
2. 将初始顶点的所有邻边加入优先队列中。
3. 当优先队列不为空时，重复以下步骤：
   - 从优先队列中取出权重最小的边。
   - 如果这条边连接的顶点已经在树中，则忽略它；否则，将该边和顶点添加到树中，并将新加入顶点的所有邻边加入优先队列。
4. 当所有顶点都被添加到树中后，算法结束。

算法特点：

- **适用于密集图**：在顶点数量较多的情况下效率较高。
- **贪心算法**：每一步都选择当前可选边中最小的边。
- **简单易实现**：尤其适用于使用邻接矩阵表示的图。

```c++
//使用邻接矩阵实现的 Prim 算法的简化版：
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int minKey(const vector<int>& key, const vector<bool>& mstSet, int V) {
    int min = INT_MAX, min_index;
    for (int v = 0; v < V; v++)
        if (mstSet[v] == false && key[v] < min)
            min = key[v], min_index = v;
    return min_index;
}

void printMST(const vector<int>& parent, const vector<vector<int>>& graph, int V) {
    for (int i = 1; i < V; i++)
        cout << parent[i] << " - " << i << " \t" << graph[i][parent[i]] << endl;
}

void primMST(const vector<vector<int>>& graph, int V) {
    vector<int> parent(V), key(V, INT_MAX);
    vector<bool> mstSet(V, false);
    key[0] = 0;
    parent[0] = -1;

    for (int count = 0; count < V - 1; count++) {
        int u = minKey(key, mstSet, V);
        mstSet[u] = true;

        for (int v = 0; v < V; v++)
            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])
                parent[v] = u, key[v] = graph[u][v];
    }

    printMST(parent, graph, V);
}

```

#### 4.4 克鲁斯卡尔算法

克鲁斯卡尔算法从边的角度出发，选择最小权重的边，同时保证不形成环，直到构成一个最小生成树。

克鲁斯卡尔算法的核心思想是按照边的权重（从小到大）顺序选择边，以构造最小生成树。在选择边的过程中，算法确保所选的边不会形成环。

算法步骤

1. **初始化**：将图中的所有边按权重排序。
2. **创建集合**：为每个顶点创建一个集合，用于判断是否形成环。
3. **选择边**：从权重最小的边开始，依次考虑每条边：
   - 如果当前边连接的两个顶点属于不同的集合，则选择这条边，并合并两个集合（即加入当前边不会形成环）。
   - 如果当前边连接的两个顶点属于同一集合，则忽略这条边（即加入当前边会形成环）。
4. **重复上述步骤**，直到选择了 `V-1` 条边，其中 `V` 是图中顶点的数量。

特点

- **适用于边比较稀疏的图**：在边数相对较少的情况下效率较高。
- **边为主导**：算法的主要操作是对边进行排序和选择。
- **不依赖起始顶点**：与 Prim 算法不同，克鲁斯卡尔算法不从特定的顶点开始。

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Edge {
    int src, dest, weight;
};

// 并查集
struct DisjointSets {
    vector<int> parent, rank;
    int n;

    DisjointSets(int n) {
        this->n = n;
        parent.resize(n);
        rank.resize(n);

        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    int find(int u) {
        if (u != parent[u])
            parent[u] = find(parent[u]);
        return parent[u];
    }

    void merge(int x, int y) {
        x = find(x), y = find(y);
        if (rank[x] > rank[y])
            parent[y] = x;
        else 
            parent[x] = y;
        if (rank[x] == rank[y])
            rank[y]++;
    }
};

int kruskalMST(vector<Edge>& edges, int V) {
    int mst_wt = 0;
    sort(edges.begin(), edges.end(), [](Edge a, Edge b) {
        return a.weight < b.weight;
    });

    DisjointSets ds(V);

    for (auto it : edges) {
        int u = it.src;
        int v = it.dest;

        int set_u = ds.find(u);
        int set_v = ds.find(v);

        if (set_u != set_v) {
            cout << u << " - " << v << endl;
            mst_wt += it.weight;
            ds.merge(set_u, set_v);
        }
    }

    return mst_wt;
}

```

### 5. 拓扑排序

#### 5.1 拓扑排序的概念和背景

拓扑排序是对有向无环图（Directed Acyclic Graph, DAG）的顶点进行排序，使得对于任何一条有向边 `u -> v`，`u` 都在 `v`
之前。拓扑排序不是唯一的。

拓扑排序在以下领域中应用广泛：

1. **任务调度**：在任务需要按特定顺序完成的场景中，如编译系统中源代码到目标代码的转换，构建系统中的任务依赖。
2. **课程规划**：学生的课程安排，其中某些课程有前置课程要求。
3. **项目管理**：在项目管理中，特别是在确定项目计划的不同阶段和活动的顺序时。

#### 5.2 拓扑排序的步骤

拓扑排序是对有向无环图（DAG）的所有顶点的线性排序，使得对于每条有向边 uv，顶点 u 在顶点 v 之前。

```c++
void topologicalSortUtil(int v, vector<bool> &visited, stack<int> &Stack, const Graph &g) {
    visited[v] = true;

    for (auto i = g.array[v].begin(); i != g.array[v].end(); ++i) {
        if (!visited[*i]) {
            topologicalSortUtil(*i, visited, Stack, g);
        }
    }

    Stack.push(v);
}

void topologicalSort(const Graph &g) {
    stack<int> Stack;
    vector<bool> visited(g.V, false);

    for (int i = 0; i < g.V; i++) {
        if (!visited[i]) {
            topologicalSortUtil(i, visited, Stack, g);
        }
    }

    while (!Stack.empty()) {
        cout << Stack.top() << " ";
        Stack.pop();
    }
}
```

### 6. 最短路径

#### 6.2 最短路径算法设计

最短路径问题是找出图中两个顶点之间的最短路径。这里是两种常见的最短路径算法的设计思路：

1. **Dijkstra 算法**：适用于加权图中的单源最短路径问题。算法思路是不断选择未访问的最近顶点，并更新其邻居的最短路径。

   ```c++
   void dijkstra(Graph const& graph, int src) {
       vector<int> dist(graph.V, INT_MAX);
       set<pair<int, int>> setds;
   
       dist[src] = 0;
       setds.insert(make_pair(0, src));
   
       while (!setds.empty()) {
           int u = setds.begin()->second;
           setds.erase(setds.begin());
   
           for (auto i = graph.adj[u].begin(); i != graph.adj[u].end(); ++i) {
               int v = (*i).first;
               int weight = (*i).second;
   
               if (dist[v] > dist[u] + weight) {
                   if (dist[v] != INT_MAX)
                       setds.erase(setds.find(make_pair(dist[v], v)));
   
                   dist[v] = dist[u] + weight;
                   setds.insert(make_pair(dist[v], v));
               }
           }
       }
   }
   ```

2. **Floyd-Warshall 算法**：用于计算图中所有顶点对之间的最短路径。它使用动态规划的方法，考虑每个顶点作为中间顶点的情况。

   ```c++
   void floydWarshall(Graph const& graph) {
       vector<vector<int>> dist(graph.V, vector<int>(graph.V, INT_MAX));
   
       for (int i = 0; i < graph.V; i++)
           for (int j = 0; j < graph.V; j++)
               dist[i][j] = graph.adjMatrix[i][j];
   
       for (int k = 0; k < graph.V; k++) {
           for (int i = 0; i < graph.V; i++) {
               for (int j = 0; j < graph.V; j++) {
                   if (dist[i][k] + dist[k][j] < dist[i][j])
                       dist[i][j] = dist[i][k] + dist[k][j];
               }
           }
       }
   }
   ```

## 22年期末试卷

### 应用解答题

1. 最大堆

```c++
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int main() {
    // 初始化最大堆
    priority_queue<string> maxHeap;

    // 给定的单词列表
    vector<string> words = {"int", "break", "else", "switch", "double", "case","char", "float", "for", "do", "if", "while"};

    // 将单词插入最大堆
    for (const string& word : words) {
        maxHeap.push(word);
    }

    // 输出最大堆中的元素
    cout << "Max Heap elements (in descending order):" << endl;
    while (!maxHeap.empty()) {
        cout << maxHeap.top() << " ";
        maxHeap.pop();
    }

    // "while", "switch", "float", "double", "else", "do", "for", "if", "int", "char", "case", "break"
    return 0;
}

```

TODO：这道题好像不太对

![image-20231218193305523](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231218193305523.png)

（1） 编号 = k * n + i

```mathematica
        0
       / \
      1   2
     / \ / \
    3  4 5  6
```

- 对于节点 1，它的第 1 个子节点是 3，计算方法是：2 * 1 + 1 = 3。
- 对于节点 2，它的第 2 个子节点是 6，计算方法是：2 * 2 + 2 = 6。

（2） 一个节点有右兄弟的条件是它不是其父节点的最后一个子节点，即n % k != k - 1

继续使用上面的二叉树例子：

- 节点 3（编号为 3）的计算方法是：3 % 2 != 1，所以它没有右兄弟。
- 节点 5（编号为 5）的计算方法是：5 % 2 != 1，所以它有右兄弟（节点 6）。

（3） 深度为 h 的满 k 叉树的节点总数 n 可以通过求解等比数列的和来得到：n = 1 + k + k^2 + k^3 + ... + k^(h-1)

​ 通过等比数列的和公式推导出来：h = logk((n-1) * (k-1) + 1)

继续使用上面的二叉树例子：

- 深度 h = 3，节点总数 n 计算为：1 + 2 + 2^2 = 7。
- 如果我们知道 n = 7，那么深度 h 的计算方法是：h = log2((7-1)*(2-1) + 1) = 3。

### 算法设计题

![image-20231218190742229](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231218190742229.png)

```c++
#include <iostream>
#include <queue>
#include <vector>
#include <string>
using namespace std;

// 1：定义哈夫曼树存储结构
struct HuffmanNode {
    char data; // 存储字符
    unsigned freq; // 字符出现的频率
    HuffmanNode *left, *right;

    HuffmanNode(char data, unsigned freq) : data(data), freq(freq), left(nullptr), right(nullptr) {}
};

// 比较函数，用于优先队列
struct Compare {
    bool operator()(HuffmanNode* l, HuffmanNode* r) {
        return l->freq > r->freq;
    }
};


// 2. 构建哈夫曼树
HuffmanNode* buildHuffmanTree(vector<char>& data, vector<unsigned>& freq, int size) {
    priority_queue<HuffmanNode*, vector<HuffmanNode*>, Compare> minHeap;

    for (int i = 0; i < size; ++i) {
        minHeap.push(new HuffmanNode(data[i], freq[i]));
    }

    while (minHeap.size() != 1) {
        HuffmanNode* left = minHeap.top();
        minHeap.pop();

        HuffmanNode* right = minHeap.top();
        minHeap.pop();

        HuffmanNode* top = new HuffmanNode('$', left->freq + right->freq);
        top->left = left;
        top->right = right;

        minHeap.push(top);
    }

    return minHeap.top();
}

//  3: 遍历哈夫曼树并按编码长度排序输出
void printCodes(HuffmanNode* root, string str, vector<pair<string, char>>& codes) {
    if (!root) return;

    if (root->data != '$') {
        codes.push_back(make_pair(str, root->data));
    }

    printCodes(root->left, str + "0", codes);
    printCodes(root->right, str + "1", codes);
}

bool compareByLength(const pair<string, char>& a, const pair<string, char>& b) {
    return a.first.length() > b.first.length();
}

void printHuffmanCodes(vector<char>& data, vector<unsigned>& freq, int size) {
    HuffmanNode* root = buildHuffmanTree(data, freq, size);
    vector<pair<string, char>> codes;
    printCodes(root, "", codes);

    sort(codes.begin(), codes.end(), compareByLength);

    // auto，自动根据codes 容器中元素的类型推断 code 的类型，方便
    for (auto& code : codes) {
        cout << code.second << ": " << code.first << endl;
    }
}


// 4: 主函数
int main() {
    vector<char> data = {'a', 'b', 'c', 'd', 'e', 'f'};
    vector<unsigned> freq = {5, 9, 12, 13, 16, 45};

    int size = data.size();
    printHuffmanCodes(data, freq, size);
    
    return 0;
}

```

