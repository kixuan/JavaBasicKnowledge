## 线性表

### 1. 线性结构

1. **线性结构定义**: 线性结构是一种顺序结构，其中元素之间是一对一的关系。在线性结构中，除第一个和最后一个元素外，每个元素都有一个前驱和一个后继。
2. **表长概念**: 表长是指线性结构中元素的数量。
3. **直接前驱和直接后继**: 在线性结构中，每个元素（除第一个和最后一个）都有一个直接前驱（前一个元素）和一个直接后继（下一个元素）。
4. **基本特征**: 线性结构的基本特征是元素之间有序排列，并且每个元素最多有一个前驱和一个后继。

### 2. 线性表

1. **线性表和线性结构**: 线性表是一种特殊的线性结构，是元素的有序集合。
2. **基本运算**:
   - **求表长**: 返回线性表中元素的数量。
   - **读表元**: 访问特定位置的元素。
   - **定位（按值查找）**: 查找具有特定值的元素位置。
   - **插入**: 在指定位置插入一个元素。
   - **删除**: 移除特定位置的元素。
3. **其它运算**: 其它运算（如排序、反转等）可以通过这些基本运算实现。

### 3. 顺序表【数组】

1. **顺序表的组成和特点**:
   - 由一个连续的内存空间和一个记录长度的变量组成。
   - 容易实现随机访问。
   - 容量与表长区别：容量是指分配的存储空间大小，表长是实际存储的元素数量。
2. **顺序表的类型定义**: 通常是一个结构体，包含一个数组和一个表示长度的变量。

### 4. 顺序表上的运算

1. **插入、删除和定位算法的思想**:
   - **插入**: 在特定位置插入元素，需要移动后续元素。
   - **删除**: 移除特定位置的元素，需要移动后续元素。
   - **定位**: 遍历表直到找到目标元素。
2. **算法图示**: 通过图示可以更直观地理解这些操作对顺序表结构的影响。
3. **算法实现**:
   - 插入和删除操作中需要注意处理边界情况和保持表的完整性。

首先，我们定义一个简单的顺序表结构：

#### 定义

```cpp
#include <iostream>
using namespace std;

const int MAX_SIZE = 100;

struct SeqList {
    int data[MAX_SIZE];
    int length;
};
```

#### 求表长

```cpp
int length(const SeqList &list) {
    return list.length;
}
```

#### 获取指定位置的元素

```cpp
int getElement(const SeqList &list, int position) {
    if (position < 1 || position > list.length) {
        cout << "Invalid position." << endl;
        return -1; // 假设顺序表不包含负数，用-1表示错误
    }
    return list.data[position - 1];
}
```

#### 按值查找

```cpp
int locateElement(const SeqList &list, int element) {
    for (int i = 0; i < list.length; i++) {
        if (list.data[i] == element) {
            return i + 1; // 返回位置（非索引）
        }
    }
    return -1; // 如果未找到
}
```

#### 插入

```cpp
void insert(SeqList &list, int position, int element) {
    if (position < 1 || position > list.length + 1 || list.length == MAX_SIZE) {
        cout << "Invalid position or list is full." << endl;
        return;
    }
    for (int i = list.length; i >= position; i--) {
        list.data[i] = list.data[i - 1];
    }
    list.data[position - 1] = element;
    list.length++;
}
```

#### 删除

```cpp
void remove(SeqList &list, int position) {
    if (position < 1 || position > list.length) {
        cout << "Invalid position." << endl;
        return;
    }
    for (int i = position; i < list.length; i++) {
        list.data[i - 1] = list.data[i];
    }
    list.length--;
}
```

#### 冒泡排序

```cpp
void bubbleSort(SeqList &list) {
    for (int i = 0; i < list.length - 1; i++) {
        for (int j = 0; j < list.length - i - 1; j++) {
            if (list.data[j] > list.data[j + 1]) {
                swap(list.data[j], list.data[j + 1]);
            }
        }
    }
}
```

#### 反转

```cpp
void reverse(SeqList &list) {
    int start = 0;
    int end = list.length - 1;
    while (start < end) {
        swap(list.data[start], list.data[end]);
        start++;
        end--;
    }
}
```

### 5. 单链表

1. **单链表的定义和特点**:
   - 每个节点包含数据和指向下一个节点的指针。
   - 适用于元素数量不定或频繁插入和删除的场景。
2. **节点结构和类型定义**:
   - 通常定义为一个包含数据和指针的结构体。
3. **头指针和头结点的区别**: 头指针是指向链表第一个节点的指针，而头结点是一个额外的、不存储实际数据的首节点，可以简化某些操作。
4. **单链表的绘制**: 用图示法表示单链表的结构。

### 6. 单链表上的运算

1. **算法的基本思想**:
   - 插入、删除、定位运算涉及指针操作和节点间关系的调整。
2. **插入和删除中的指针操作**:
   - 需要正确处理指针以维护链表的结构。

#### 起始定义

```cpp
truct ListNode {
    int data;
    ListNode* next;
    // 构造函数简化书写，x初始化data，nullptr初始化next
    ListNode(int x) : data(x), next(nullptr) {}
};
// 创建一个新的链表节点
ListNode* createNode(int value) {
    return new ListNode(value);
}
```

#### 求表长

```cpp
int length(ListNode* head) {
    int count = 0;
    ListNode* current = head;
    while (current != nullptr) {
        count++;
        current = current->next;
    }
    return count;
}
```

#### 按值查找

```cpp
ListNode* searchByValue(ListNode* head, int value) {
    ListNode* current = head;
    while (current != nullptr) {
        if (current->data == value) {
            return current;
        }
        current = current->next;
    }
    return nullptr; // 如果没有找到
}
```

#### 按序号查找

```cpp
ListNode* searchByIndex(ListNode* head, int index) {
    int count = 0;
    ListNode* current = head;
    while (current != nullptr && count < index) {
        current = current->next;
        count++;
    }
    return current; // 如果index超出链表长度，返回nullptr
}
```

#### 插入操作

```cpp
void insertAfter(ListNode* node, int element) {
    if (node == nullptr) return;
    ListNode* newNode = new ListNode(element);
    newNode->next = node->next;
    node->next = newNode;
}
```

#### 删除操作

```cpp
void deleteNode(ListNode*& head, ListNode* nodeToDelete) {
    // 处理空链表或没有指定删除的节点
    if (head == nullptr || nodeToDelete == nullptr) return;

    // 如果要删除的是头节点
    if (head == nodeToDelete) {
        ListNode* nextNode = head->next;
        delete head;  // 释放头节点
        head = nextNode;  // 更新头节点
        return;
    }

    // 查找 nodeToDelete 的前驱节点
    ListNode* current = head;
    while (current->next != nullptr && current->next != nodeToDelete) {
        current = current->next;
    }

    // 如果找到 nodeToDelete
    if (current->next == nodeToDelete) {
        current->next = nodeToDelete->next;  // 跳过 nodeToDelete
        delete nodeToDelete;  // 释放 nodeToDelete 节点
    }
}

```

#### 转链表

```cpp
ListNode* reverse(ListNode* head) {
    ListNode *prev = nullptr, *current = head, *next = nullptr;
    while (current != nullptr) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    return prev; // 新的头节点
}
```

#### 删除特定值的节点

```cpp
void deleteByValue(ListNode*& head, int value) {
    ListNode *current = head, *prev = nullptr;
    while (current != nullptr) {
        if (current->data == value) {
            if (prev == nullptr) {
                head = current->next;
            } else {
                prev->next = current->next;
            }
            delete current;
            return;
        }
        prev = current;
        current = current->next;
    }
}
```


### 7. 循环链表和双向链表

1. **循环链表**: 在循环链表中，最后一个节点指向第一个节点，形成一个闭环。
2. **双向链表**: 双向链表的每个节点都有两个指针，分别指向前一个和后一个节点。

#### 循环链表

循环链表与普通的单链表类似，不同之处在于循环链表的最后一个节点指向头节点，形成一个环。

##### 基本定义

```cpp
struct CircularListNode {
    int data;
    CircularListNode* next;

    CircularListNode(int x) : data(x), next(this) {}
};
```

##### 插入操作

在循环链表中插入节点通常包括在头部或尾部插入。这里展示在尾部插入新节点的操作：

```cpp
void insertAtEnd(CircularListNode*& head, int value) {
    CircularListNode* newNode = new CircularListNode(value);
    if (head == nullptr) {
        head = newNode;
    } else {
        CircularListNode* temp = head;
        while (temp->next != head) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->next = head;
    }
}
```

##### 删除操作

删除循环链表中的节点也需要特别处理，以下是删除头节点的示例：

```cpp
void deleteAtHead(CircularListNode*& head) {
    if (head == nullptr) return;
    if (head->next == head) {
        delete head;
        head = nullptr;
    } else {
        CircularListNode* temp = head;
        while (temp->next != head) {
            temp = temp->next;
        }
        temp->next = head->next;
        delete head;
        head = temp->next;
    }
}
```

#### 双向链表

双向链表的每个节点都有两个指针，分别指向前一个节点和后一个节点。

##### 基本定义

```cpp
struct DoubleListNode {
    int data;
    DoubleListNode *prev, *next;

    DoubleListNode(int x) : data(x), prev(nullptr), next(nullptr) {}
};
```

##### 插入操作

在双向链表中插入节点通常包括在头部、尾部或指定位置插入。这里展示在尾部插入新节点的操作：

```cpp
void insertAtEnd(DoubleListNode*& head, int value) {
    DoubleListNode* newNode = new DoubleListNode(value);
    if (head == nullptr) {
        head = newNode;
    } else {
        DoubleListNode* temp = head;
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->prev = temp;
    }
}
```

##### 删除操作

删除双向链表中的节点时，需要更新前驱和后继节点的指针。以下是删除指定节点的示例：

```cpp
void deleteNode(DoubleListNode*& head, DoubleListNode* nodeToDelete) {
    if (head == nullptr || nodeToDelete == nullptr) return;
    if (nodeToDelete == head) {
        head = nodeToDelete->next;
    }
    // 举例：A ↔ B ↔ C
    if (nodeToDelete->next != nullptr) {
        nodeToDelete->next->prev = nodeToDelete->prev;
    }
    if (nodeToDelete->prev != nullptr) {
        nodeToDelete->prev->next = nodeToDelete->next;
    }
    delete nodeToDelete;
}
```

### 8. 顺序表与链表的比较

1. **顺序表的优缺点**:
   - 优点：可随机访问，存储密度高。
   - 缺点：容量不易估计，插入和删除效率低。
2. **链表的优缺点**:
   - 优点：插入和删除高效，容量灵活。
   - 缺点：存储密度低，无法随机访问。

## 栈和队列

### 1. 栈（Stack）

#### 1.1 栈的逻辑结构

- 栈是一种特殊的线性结构。
- 遵循后进先出（LIFO, Last In First Out）原则。

#### 1.2 基本运算和特点

- **基本操作**：进栈（push）、退栈（pop）、查看栈顶（peek）。
- **特点**：只在栈顶添加或删除元素，不允许在其他位置进行操作。
- **与线性表的异同**：栈是受限的线性表，只允许在一端进行操作。

#### 1.3 简单应用

- 应用示例：括号匹配、逆波兰表达式（后缀表达式）计算等。

#### 2.1 顺序栈的组织和类型定义

- 使用数组实现。
- 类型定义：包含一个数组和一个指示栈顶位置的变量。
- **上溢**：尝试向已满的栈中添加元素。
- **下溢**：尝试从空栈中取出元素。

#### 2.2 顺序栈的进栈和退栈实现

- **进栈**：在栈顶添加元素。
- **退栈**：从栈顶移除元素。
- 栈满和栈空的条件检查。

顺序栈的实现：

```cpp
class ArrayStack {
private:
    int* stack;
    int maxSize;
    int top;

public:
    ArrayStack(int size) {
        maxSize = size;
        stack = new int[maxSize];
        top = -1;
    }

    ~ArrayStack() {
        delete[] stack;
    }

    void push(int value) {
        if (top >= maxSize - 1) {// 栈上溢
            return;
        }
        stack[++top] = value;
    }

    int pop() {
        if (top < 0) {// 栈下溢
            return INT_MIN;
        }
        return stack[top--];
    }

    int peek() {
        if (top < 0) {
            return INT_MIN;
        }
        return stack[top];
    }

    bool isEmpty() {
        return top < 0;
    }
};

```

#### 2.3 顺序栈上的算法设计

#### 示例1: 括号匹配检查

```c++
bool areBracketsBalanced(string expr) {
    stack<char> stack;

    for (char ch : expr) {
        if (ch == '(' || ch == '[' || ch == '{') {
            // 如果是左括号，推入栈中
            stack.push(ch);
        } else {
            // 如果是右括号，检查栈顶元素
            if (stack.empty()) return false;

            char top = stack.top();
            if ((ch == ')' && top != '(') ||
                (ch == ']' && top != '[') ||
                (ch == '}' && top != '{')) {
                return false;
            }

            stack.pop(); // 匹配则弹出栈顶元素
        }
    }

    return stack.empty(); // 检查栈是否为空
}
```

示例2: 中缀表达式转后缀表达式

```c++
int getPrecedence(char ch) {
    if (ch == '+' || ch == '-') return 1;
    if (ch == '*' || ch == '/') return 2;
    return 0;
}

string infixToPostfix(string infix) {
    stack<char> stack;
    string postfix;

    for (char ch : infix) {
        if (isalnum(ch)) {
            postfix += ch;
        } else if (ch == '(') {
            stack.push(ch);
        } else if (ch == ')') {
            while (!stack.empty() && stack.top() != '(') {
                postfix += stack.top();
                stack.pop();
            }
            stack.pop(); // Pop the '('
        } else {
            while (!stack.empty() && getPrecedence(ch) <= getPrecedence(stack.top())) {
                postfix += stack.top();
                stack.pop();
            }
            stack.push(ch);
        }
    }

    while (!stack.empty()) {
        postfix += stack.top();
        stack.pop();
    }

    return postfix;
}

```


#### 3. 栈的链接实现

- 使用链表实现。
- **节点形式**：每个节点包含数据和指向下一个节点的指针。
- **链栈组织方法**：头部作为栈顶。

#### 3.2 链栈的进栈和退栈算法

- **进栈**：在链表头部添加节点。
- **退栈**：从链表头部移除节点。

```c++
struct ListNode {
    int data;
    ListNode* next;

    ListNode(int x) : data(x), next(nullptr) {}
};

class LinkedStack {
private:
    ListNode* top;

public:
    LinkedStack() {
        top = nullptr;
    }

    ~LinkedStack() {
        while (!isEmpty()) {
            pop();
        }
    }

    void push(int value) {
        ListNode* newNode = new ListNode(value);
        newNode->next = top;
        top = newNode;
    }

    int pop() {
        if (top == nullptr) {
            return INT_MIN;
        }
        ListNode* temp = top;
        int value = top->data;
        top = top->next;
        delete temp;
        return value;
    }

    int peek() {
        if (top == nullptr) {
            return INT_MIN;
        }
        return top->data;
    }

    bool isEmpty() {
        return top == nullptr;
    }
};

```

#### 3.4 顺序栈与链栈的区别

- **顺序栈**：固定大小，快速访问，空间效率可能低。
- **链栈**：动态大小，稍慢的访问，更高的空间效率。

### 4. 队列（Queue）

#### 4.1 队列的逻辑结构

- 队列是一种线性结构。
- 遵循先进先出（FIFO, First In First Out）原则。

#### 4.2 队列的基本运算和特点

- **基本操作**：入队（enqueue）、出队（dequeue）、查看队首（front）。
- **特点**：在队尾添加元素，在队首删除元素。

#### 4.3 队列与栈的异同

- **相同**：都是线性结构。
- **不同**：栈是 LIFO，队列是 FIFO。

#### 4.4 队列与线性表的异同

- **相同**：都是线性结构。
- **不同**：队列操作受限于两端，线性表可在任意位置操作。

#### 5.1 顺序队列的组织和“假溢出”

- 使用数组实现。
- **假溢出**：尽管数组中还有空间，但无法在队尾添加新元素。为了区分队空和队满的情况
   - **队列为空**的条件是 `front == rear`。
   - **队列为满**的条件是 `(rear + 1) % maxSize == front`。

#### 5.2 循环队列的组织

- 使用循环数组避免假溢出。
- 循环队列的入队和出队操作。
- 队满和队空的条件。

<img src="https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231207090024083.png" alt="image-20231207090024083" style="zoom:150%;" />

```c++
class ArrayQueue {
private:
    int* queue;
    int maxSize;
    // front 第一个元素
    // rear 队列中最后一个元素的下一个位置。这是新元素将要被入队的位置
    int front, rear;

public:
    ArrayQueue(int size) {
        maxSize = size;
        queue = new int[maxSize];
        front = 0;
        rear = 0;
    }

    ~ArrayQueue() {
        delete[] queue;
    }

    void enqueue(int value) {
        if ((rear + 1) % maxSize == front) {// 队满
            return;
        }
        queue[rear] = value;
        rear = (rear + 1) % maxSize;
    }

    int dequeue() {
        if (front == rear) { // 队空
            return INT_MIN;
        }
        int value = queue[front];
        front = (front + 1) % maxSize;
        return value;
    }

    int peek() {
        if (front == rear) {
            return INT_MIN;
        }
        return queue[front];
    }

    bool isEmpty() {
        return front == rear;
    }
};

```

#### 6.1 链队的组织和类型定义

- 使用链表实现。
- **节点形式**：每个节点包含数据和指向下一个节点的指针。
- **链队组织方法**：队首和队尾指针。

#### 6.2 链队的入队和出队算法

- **入队**：在链表尾部添加节点。
- **出队**：从链表头部移除节点。

```c++
class LinkedQueue {
private:
    ListNode *front, *rear;

public:
    LinkedQueue() {
        front = nullptr;
        rear = nullptr;
    }

    ~LinkedQueue() {
        while (!isEmpty()) {
            dequeue();
        }
    }

    void enqueue(int value) {
        ListNode* newNode = new ListNode(value);
        if (rear == nullptr) {
            front = rear = newNode;
            return;
        }
        rear->next = newNode;
        rear = newNode;
    }

    int dequeue() {
        if (front == nullptr) {
            return INT_MIN;
        }
        ListNode* temp = front;
        int value = front->data;
        front = front->next;
        if (front == nullptr) {
            rear = nullptr;
        }
        delete temp;
        return value;
    }

    int peek() {
        if (front == nullptr) {
            return INT_MIN;
        }
        return front->data;
    }

    bool isEmpty() {
        return front == nullptr;
    }
};

```

#### 6.3 链队上算法的设计

示例: 队列应用 - 任务调度

```c++
class TaskScheduler {
private:
    queue<int> taskQueue;

public:
    void addTask(int taskId) {
        taskQueue.push(taskId);
    }

    void executeTasks() {
        while (!taskQueue.empty()) {
            int taskId = taskQueue.front();
            taskQueue.pop();

            // 执行任务
            cout << "Executing task " << taskId << endl;
        }
    }
};

```

#### 示例2: 翻转队列

```c++
void reverseQueue(LinkedQueue &queue) {
    stack<int> stack;
    
    // 将队列元素移到栈中
    while (!queue.isEmpty()) {
        stack.push(queue.dequeue());
    }

    // 再次将元素从栈移回队列
    while (!stack.empty()) {
        queue.enqueue(stack.top());
        stack.pop();
    }
}
```

### 7. 递归算法的思想及设计方法

- 递归是一种通过函数自己调用自己来解决问题的方法。
- 递归算法通常包括基本情况（递归终止条件）和递归步骤。
- 递归应用示例：阶乘计算、斐波那契数列、树的遍历等。

## 树

### 1. 树结构的基本概念和术语

#### 1.1 树的定义

- 树是一种**非线性数据结构**，由**节点**（nodes）组成。
- 包括一个称为**根**（root）的节点以及零个或多个子树，这些子树也是树，并且它们的根节点被连接到根节点。

#### 1.2 树结构的术语

- **根节点（Root）**：没有父节点的节点。
- **子节点（Child）**：一个节点直接连接的节点。
- **父节点（Parent）**：有子节点的节点。
- **叶节点（Leaf）**：没有子节点的节点。
- **兄弟（Siblings）**：具有相同父节点的节点。
- **深度（Depth）**：根节点到当前节点的唯一路径上的边数。【从树底向上测量的】
- **高度（Height）**：节点到叶节点的最长路径上的边数。【从树顶向下测量的】

```mathematica
        A           <-- 根节点
       / \
      B   C
     /     \
    D       E
           / \
          F   G
```

深度：A-0，BC-1，DE-2，FG-3

高度：FGD-0，BE-1，C-2，1-3

#### 1.3 树结构的实际背景

- 用于表示具有层级关系的数据，例如文件系统、组织结构等。

### 2. 二叉树的定义和特点

#### 2.1 二叉树的逻辑结构和特点

- 每个节点最多有两个子节点：通常称为左子节点和右子节点。
- 二叉树的五种基本形态：空树、只有根节点、根节点只有左子树、根节点只有右子树、根节点有左右两个子树。

#### 2.2 二叉树的基本运算

- 插入、删除、搜索节点等。【详细代码见下面】

### 3. 二叉树的链式存储结构

#### 3.1 二叉链表的节点形式和类型定义

```c++
struct TreeNode {
    int data;
    TreeNode *left, *right;

    //构造函数
    TreeNode(int x) : data(x), left(nullptr), right(nullptr) {}
};
```

#### 3.2 二叉链表示例

```c++
// 创建示例二叉树
TreeNode* createSampleTree() {
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    return root;
}

// 一般插入
TreeNode* insert(TreeNode* root, int value) {
    if (root == nullptr) {
        return new TreeNode(value);
    }

    if (value < root->data) {
        root->left = insert(root->left, value);
    } else if (value > root->data) {
        root->right = insert(root->right, value);
    }

    return root;
}

// TODO:特定位置插入
void insertAtSpecificPosition(TreeNode* parent, int value, bool insertLeft) {
    TreeNode* newNode = new TreeNode(value);

    if (insertLeft) {
        // 检查左子节点是否为空
        if (parent->left == nullptr) {
            parent->left = newNode;
        } else {
            // 已存在左子节点，可以根据需要处理这种情况
            // 例如，可以替换或者不进行插入
        }
    } else {
        // 检查右子节点是否为空
        if (parent->right == nullptr) {
            parent->right = newNode;
        } else {
            // 已存在右子节点，可以根据需要处理这种情况
        }
    }
}


// 查找【普通二叉树，而不是二叉搜索树】
TreeNode* search(TreeNode* root, int value) {
    if (root == nullptr || root->data == value) {
        return root;
    }
    // 遍历递归左子树
    TreeNode* leftSearch = search(root->left, value);
    if (leftSearch != nullptr) {
        return leftSearch;
    }
    // 遍历递归右子树
    return search(root->right, value);
}

// 查找【二叉搜索树】
TreeNode* search(TreeNode*root ,int data){
    if(root==nullptr||root->data==data) return root;
    if(data<root->data) return search(root->left,data);
    if(data>root->data) return search(root->right,data);
}

// 更新节点
void updateNode(TreeNode* root, int oldValue, int newValue) {
    if (root == nullptr) return;
    if (root->data == oldValue) {
        root->data = newValue;
        return;
    }
    updateNode(root->left, oldValue, newValue);
    updateNode(root->right, oldValue, newValue);
}

// 删除节点
// 传入指针引用（好古老的知识点：适用于需要在函数内部管理内存（如分配或释放内存）并希望这些改变反映到原始指针上的场景。
// 直接传入指针：适用于只需要操作指针指向的数据，而不需要改变指针本身的场景，像更新的话就是只更新指向的数据
void deleteNode(TreeNode *& root,int data){
    if(root == nullptr) return root;
    if(data<root->data) deleteNode(root->left,data);
    else if(data>root->data) deleteNode(root->right,data);
    // 找到删除节点
    else {
        // 有两个节点的情况
        if(root->left!=nullptr&&root->right!=nullptr){
            // 找到右子树最左边的节点，这个节点是比root大的最小值，把这个节点替换root可以保持二叉搜索树的特性
            TreeNode* minNode = minValueNode(root->right);
            // 将找到节点の值赋给root
            root->data = minNode->data;
            // 删除这个节点，也就是原来的最小值节点的位置
            // 相当于再进一次“没有子节点”或“只有一个子节点”的删除情况，使得删除操作相对简单
            deleteNode(root->right,minNode->data);
        }else{
            TreeNode*temp = root->left?root->left:root->right;
            // 没有子节点的情况
            if(temp == nullptr){
                delete root;
                // 防止产生悬挂指针（dangling pointer），即一个仍然指向已经释放内存的指针。悬挂指针可能导致未定义的行为，包括程序崩溃和数据损坏
                root = nullptr;
            } else {
                // 只有一个子节点的情况，直接将root设为子节点的值然后删掉子节点
                // *表示解引用，就是root和temp其实都是指针，如果直接root = temp的话只是将root指向temp指向的TreeNODE，并不是真正的改变TreeNODE对象
                // 所以这里要解引用相等，直接让两个TreeNODE对象相等
                // 那又有个问题了，为什么不直接用对象而是用指针？
                // 1. 指针可以灵活动态创建和销毁节点 2.效率高，内存占用小 3.可以实现多个节点共享对同一个节点的引用
                 *root = *temp;
            }
            delete temp;
        }
    }
}

// 删除节点辅助函数，找到以root为根的树中的最小值节点
TreeNode* minValueNode(TreeNode* root) {
    TreeNode* current = root;
    while (current && current->left != nullptr) {
        current = current->left;
    }
    return current;
}

// 遍历-中序遍历
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    inorderTraversal(root->left);
    cout << root->data << " ";
    inorderTraversal(root->right);
}

```

#### 3.3 三叉链表的结点形式和组织方法

​ 类似于二叉链表，但每个节点还有一个指向父节点的指针。特别有助于在树中向上遍历，即从某个节点回到其父节点，而在普通的二叉树链表中，这通常是不可能的。

```c++
struct TriNode {
    int data;
    TriNode *left;
    TriNode *right;
    TriNode *parent;

    TriNode(int value) : data(value), left(nullptr), right(nullptr), parent(nullptr) {}
};

```

### 4. 二叉树的顺序存储结构

#### 4.1 满二叉树和完全二叉树

- **满二叉树**：所有层都完全填满，没有任何空缺。
- **完全二叉树**：除最后一层外，每层都是满的，并且最后一层的节点一定是靠左排列的。

#### 4.2 顺序存储的基本思想

- 通常使用数组来表示二叉树，特别适用于完全二叉树。
- 每个节点的位置可以根据其在树中的层次和顺序计算出来。

```c++
// TODO：只要求识记代码看看就行
// 定义
const int MAX_SIZE = 100;

struct BinaryTree {
    int nodes[MAX_SIZE];
    int size;

    BinaryTree() : size(0) {
        for (int i = 0; i < MAX_SIZE; i++) 
            nodes[i] = INT_MIN; // 使用特殊值表示空节点
    }
};

// 插入
void insert(BinaryTree &tree, int value) {
    if (tree.size >= MAX_SIZE) {
        // 树已满
        return;
    }
    tree.nodes[tree.size++] = value;
}

// 查找
int getNode(const BinaryTree &tree, int index) {
    if (index < 0 || index >= tree.size) {
        return INT_MIN; // 表示无效索引
    }
    return tree.nodes[index];
}

//遍历
void levelOrderTraversal(const BinaryTree &tree) {
    for (int i = 0; i < tree.size; i++) {
        if (tree.nodes[i] != INT_MIN) {
            cout << tree.nodes[i] << " ";
        }
    }
}

```

#### 4.3 父子节点编号关系

- 在数组中，如果根节点的索引是0，位置 `i` 的节点的左子节点是 `2*i + 1`，右子节点是 `2*i + 2`，父节点是 `(i-1)/2`。
- 如果根节点的索引是1，位置 `i` 的节点的左子节点是 `2*i`，右子节点是 `2*i + 1`，父节点是 `i/2`。

### 5. 二叉树的遍历

#### 5.1 遍历方法

- **前序遍历（Pre-order）**：中 - 左 - 右
- **中序遍历（In-order）**：左 - 中 - 右
- **后序遍历（Post-order）**：左 - 右 - 中
- **层次遍历（Level-order）**：逐层从左到右访问每个节点

举例：

```mathematica
        A
       / \
      B   C
     / \   \
    D   E   F
```

前序遍历：访问根节点->左子树->右子树。遍历的顺序是：ABDECF

中序遍历：访问左子树->根节点->右子树。遍历的顺序是：DBEACF

后序遍历：访问左子树->右子树->根节点。遍历的顺序是：DEBFCA

层次遍历：遍历的顺序是：ABCDEF

#### 5.2 遍历算法实现

**巧记：中的位置--》cout的位置--》什么序**

```c++
// 前序遍历
void preorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    cout << root->data << " ";
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}

// 中序
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    inorderTraversal(root->left);
    cout << root->data << " ";
    inorderTraversal(root->right);
}

// 后序
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    cout << root->data << " ";
}

// 层次，一般使用队列实现，广度优先搜索
void levelOrderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        //从队列中弹出第一个节点（front()）。
        //访问该节点（例如，打印节点的数据）。
		//将该节点的左右子节点（如果存在）加入队列。
        TreeNode* current = q.front();
        q.pop();
        cout << current->data << " ";

        if (current->left != nullptr) 
            q.push(current->left);
        if (current->right != nullptr)
            q.push(current->right);
    }
}

```

#### 5.3 遍历算法异同

**相同点**：所有遍历方法都是系统地访问树中的每个节点一次，但访问的顺序不同。

**不同点**：每种遍历方法侧重于不同的访问顺序，适用于不同的应用场景。

- **前序遍历**：首先访问根节点，适用于创建树的副本。
- **中序遍历**：对于二叉搜索树，可以按升序访问节点。
- **后序遍历**：首先处理子节点，适用于删除或释放节点。
- **层次遍历**：按树的层级逐层访问，适用于广度优先搜索。

#### 5.4 遍历算法实际问题的应用

1. **前序遍历应用**：
   - 树的副本创建。
   - 表达式树的操作。
   - 目录结构的遍历。
2. **中序遍历应用**：
   - 二叉搜索树的有序遍历。
   - 表达式树的中缀表示。
3. **后序遍历应用**：
   - 二叉树的删除或释放。
   - 表达式树的后缀表示。
   - 用于计算给定树的各种属性（如高度、大小）。
4. **层次遍历应用**：
   - 广度优先搜索。
   - 查找最小深度。
   - 层级顺序打印。

### 6. 树和森林

#### 6.1 树的逻辑结构和运算

- 树是一种非线性数据结构，它模拟了一个层级关系（如家族树、组织结构）。
- 在树中，每个节点可以有零个或多个子节点，但只有一个父节点（除了根节点）。
- 基本运算包括添加子节点、删除子节点、遍历等。

#### 6.2 树、森林与二叉树的转换

- 任何一棵树都可以转换为一棵二叉树，其中每个节点的左子节点是其第一个子节点，右子节点是其下一个兄弟节点。
- 森林（多棵树的集合）可以转换为一棵二叉树，其中每棵树转换为二叉树后，第一棵树的根是二叉树的根，其余树的根是前一棵树根的右子节点。

#### 6.3 树的存储结构

- 链式存储结构、顺序存储结构、索引存储结构等。【后面两种用的都是数组，可以直接根据索引找到位置，适用于完全二叉树，几乎没有内存空间被浪费，但如果是普通的二叉树的话就会有空间被浪费】

### 7. 树的应用

#### 7.1 判定树和哈夫曼树

- **判定树**：用于决策和分类。
- **哈夫曼树（Huffman Tree）**：用于数据压缩。

#### 7.2 哈夫曼树构造算法

**概念和背景**

- 哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。
- 用于数据压缩（如哈夫曼编码），在编码中频率高的字符使用较短的编码，频率低的使用较长的编码。

**构造算法**

1. **统计频率**：
   - 对每个字符及其出现的频率进行统计。
   - 将每个字符视作一个节点，并根据频率为这些节点赋予权重。
2. **初始化优先队列**：
   - 创建一个优先队列（或最小堆），并将所有节点插入队列中。
   - 优先队列按照节点的权重（频率）排序。
3. **构建树**：
   - 只要优先队列中的节点数量大于1，执行以下步骤：
      - 从队列中弹出两个频率最低的节点（权重最小的节点）。
      - 创建一个新节点作为这两个节点的父节点，其频率是这两个节点频率的和。
      - 将新节点插入优先队列。
4. **完成构造**：
   - 当优先队列只剩下一个节点时，这个节点就是哈夫曼树的根节点，此时树的构造完成。
5. **生成哈夫曼编码**：
   - 从根节点开始，遍历树的每个叶节点。
   - 每向左走一步，添加一个“0”到编码中；每向右走一步，添加一个“1”。
   - 到达叶节点时，得到的编码即为该节点（字符）的哈夫曼编码。

假设有一组字符及其频率如下：

```
字符：a,  b,  c,  d
频率：45, 13, 12, 16
```

按照哈夫曼树构造算法：

1. 初始化优先队列，包含所有字符及其频率。
2. 首先合并频率最低的两个节点，比如 `b` 和 `c`（频率分别为 13 和 12），创建一个新节点，其频率为 25（13 + 12）。
3. 将新节点（频率为 25）放回优先队列。
4. 继续这个过程，直到优先队列中只剩下一个节点。

#### 7.3 哈夫曼树的应用

- 哈夫曼树被用于构建高效的压缩算法和数据编码系统。
- 在通信系统中用于数据传输的优化。

```c++
// 定义哈夫曼树的节点
struct HuffmanNode {
    char data;
    unsigned freq;  // 字符频率之和
    HuffmanNode *left, *right;

    HuffmanNode(char data, unsigned freq) {
        left = right = nullptr;
        this->data = data;
        this->freq = freq;
    }
    // HuffmanNode(char data, unsigned freq) : data(data), freq(freq), left(nullptr), right(nullptr) {}

};

// 用于优先级队列（小顶堆）的比较函数，比较频率，确保每次从堆中取出的两个节点是频率最低的；
struct compare {
    // 重载operator方法
    bool operator()(HuffmanNode* l, HuffmanNode* r) {
        return (l->freq > r->freq);
    }
};


// 使用优先级队列（小顶堆）构建哈夫曼树
HuffmanNode* buildHuffmanTree(char data[], int freq[], int size) {
    struct compare cmp;
    // priority_queue是c++标准模板库中的一种数据结构，提供队列功能，保证队列中的元素始终是有序的
    // HuffmanNode* - 队列存储的元素类型
    // vector<HuffmanNode*> - 内部存储结构
    // compare - 提供比较逻辑的函数对象类型 - cmp
    priority_queue<HuffmanNode*, vector<HuffmanNode*>, compare> minHeap(cmp);

    for (int i = 0; i < size; ++i)
        minHeap.push(new HuffmanNode(data[i], freq[i]));

    // 构建哈夫曼树：
	// 每次从堆中取出两个频率最低的节点。
	// 创建一个新的内部节点，其频率是这两个节点频率之和。
	// 将这两个节点作为新创建的内部节点的子节点。
	// 将新节点加入到堆中。
    
    // 队列只剩下最后一个节点，这个节点就是哈夫曼树的根节点
    while (minHeap.size() != 1) {
        // 返回队列的第一个元素--》频率最小的节点
        HuffmanNode *left = minHeap.top();
        minHeap.pop();
        // 频率第二小的节点
        HuffmanNode *right = minHeap.top();
        minHeap.pop();

        // 创建一个新的内部节点，这个节点的频率为两个节点的和，left和right是top的左右子节点，使用$就是为了区分叶子节点和内部节点，下面的generateHuffmanCodes会用到
        HuffmanNode *top = new HuffmanNode('$', left->freq + right->freq);
        top->left = left;
        top->right = right;

        // 把新创建的节点放回队列
        minHeap.push(top);
    }
    return minHeap.top();
}


// 递归地生成哈夫曼编码并存储在一个哈希表中
// 编码是根据从根到叶子的路径生成的，其中向左走记录为 "0"，向右走记录为 "1"。
void generateHuffmanCodes(struct HuffmanNode* root, string str, unordered_map<char, string> &huffmanCode) {
    if (!root)
        return;

    if (root->data != '$')
        huffmanCode[root->data] = str;

    generateHuffmanCodes(root->left, str + "0", huffmanCode);
    generateHuffmanCodes(root->right, str + "1", huffmanCode);
}

// 对一个字符串进行哈夫曼编码
void printHuffmanCodes(char data[], int freq[], int size) {
    HuffmanNode* root = buildHuffmanTree(data, freq, size);
    unordered_map<char, string> huffmanCode;
    generateHuffmanCodes(root, "", huffmanCode);

    cout << "Huffman Codes are :\n";
    for (auto pair : huffmanCode) {
        cout << pair.first << ": " << pair.second << endl;
    }
}

int main() {
    char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
    int freq[] = { 5, 9, 12, 13, 16, 45 };

    int size = sizeof(arr) / sizeof(arr[0]);
    printHuffmanCodes(arr, freq, size);

    return 0;
}

```

## 图

### 学习目标

1. 图的概念，要求达到“领会”层次。
   1.1 弄清图状结构的定义并熟悉有关术语。
   1.2 清楚图状结构与树形结构之异同。


2. 图的存储结构，要求达到“简单应用”层次。
   2.1 掌握有向图、无向图和无向网络的邻接表表示法及其类型定义
   2.2 知道邻接矩阵表示法和邻接表表示法的相对优缺点。
   2.3 能对任意给定的图状结构画出其邻接矩阵和邻接表
   2.4 掌握无向网络的邻接矩阵的建立方法和算法。
   2.5 掌握无向图的邻接表的建立方法和算法。


3. 图的遍历，要求达到“综合应用”层次。
   3.1 弄清连通图的浓度优先搜索的基本思想、基本步骤和算法
   3.2 弄清连通图的广度优先搜索的基本思想、基本步骤和算法。
   3.3 非连通图的遍历方法以及图的连通分量的求法
   3.4 掌握对给定的无向图，能画出它的存储结构并进而确定其深度搜索序列和广度优先搜索序列。
   3.5 掌握图的遍历算法的设计以及应用到实际问题的求解。


4. 最小生成树，要求达到“简单应用”的层次。
   4.1 清楚生成树和最小生成树的概念，最小生成树的应用背景
   4.2 弄清 Prim 算法的基本思想和有关原理，并能据此有图示法表示出求给定网络的一棵最小生成树的过程。
   4.3 熟练掌握 Prim 算法的设计过程。
   4.4 熟练掌握克鲁斯卡尔算法的设计过程。


5. 拓扑排序，要求达到“简单应用”层次
   5.1 掌握拓扑排序的基本概念和实际背景。
   5.2 掌握拓扑排序的基本步骤
   5.3 熟练掌握拓扑排序的算法设计过程


6. 最短路径，要求达到“简单应用”层次。
   6.1 知道求最短路径的基本步骤。
   6.2 熟练掌握最短路径的算法设计过程

### 1. 图的概念

#### 1.1 图的定义和术语

- **图（Graph）**: 一组顶点和连接这些顶点的边的集合。
- **顶点（Vertex）**: 图的基本元素，通常代表一个实体。
- **边（Edge）**: 连接一对顶点的线段，可以是有向的（箭头指向）或无向的（没有箭头）。
- **路径（Path）**: 顶点的一个序列，其中每对相邻的顶点都通过边连接。

#### 1.2 图与树的异同

- **相同点**：都是由节点和边组成。
- **不同点**：树是一种特殊的图，它是无环的，并且有一个特定的根节点。图可以有环，也可能没有根节点。

### 2. 图的存储结构

#### 2.1 邻接表表示法

对于每个顶点，维护一个**链表**，列出与其直接相连的所有顶点。这种表示法适用于稀疏图。

![image-20231219145025693](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231219145025693.png)

类型定义：

```c++
#include <vector>
#include <list>
#include <utility>

class WeightedGraph {
    int numVertices;
    // 使用 pair 来存储相邻顶点和权重
    std::vector<std::list<std::pair<int, int>>> adjLists;

public:
    WeightedGraph(int vertices) : numVertices(vertices), adjLists(vertices) {}

    void addEdge(int src, int dest, int weight) {
        adjLists[src].push_back(std::make_pair(dest, weight));
        // 由于是无向网络，所以还需要添加反向边
        adjLists[dest].push_back(std::make_pair(src, weight));
    }
};

```

#### 2.2 邻接矩阵表示法

使用一个**二维数组**来表示图。如果顶点 `i` 和顶点 `j` 相连，则 `matrix[i][j]` 为 `1`（或权重值），否则为 `0`。

简单版代码：以左上到右下的对角线对称，这条对角线全为0

```c++
char vex[ 6 ] = { 'A', 'B', 'C', 'D', 'E', 'F'};//节点数组
int arcs[6][6] = {
        0, 1, 0, 0, 0, 1,
        1, 0, 1, 0, 1, 0,
        0, 1, 0, 1, 0, 1,
        0, 0, 1, 0, 1, 0,
        0, 1, 0, 1, 0, 1,
        1, 0, 1, 0, 1, 0
};//邻接矩阵
```

复杂版代码：
```c++
#include <iostream>
#include <vector>
using namespace std;

class Graph {
    int V; // 顶点的数量
    vector<vector<int>> adjMatrix; // 邻接矩阵

public:
    Graph(int V) {
        this->V = V;
        adjMatrix.resize(V, vector<int>(V, 0));
    }

    // 添加边
    void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;
        adjMatrix[v][u] = 1; // 由于是无向图，所以是对称的
    }

    // 打印邻接矩阵
    void printAdjMatrix() {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) 
                cout << adjMatrix[i][j] << " ";
            cout << endl;
        }
    }
};

int main() {
    // 创建有 4 个顶点的图
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);

    cout << "The adjacency matrix of the graph:\n";
    g.printAdjMatrix();

    return 0;
}

```

#### 2.3 优缺点比较

- **邻接矩阵**：适用于密集图，**易于实现**，但可能浪费空间。
- **邻接表**：适用于稀疏图，**空间效率更高**，但实现相对复杂。

#### 2.4 无向网络的邻接矩阵建立方法和算法

无向网络可以使用邻接矩阵进行存储，其中矩阵的每个元素表示两个顶点之间的连接关系。在无向网络中，邻接矩阵是对称的。

```c++
class Graph {
    int V;   // 顶点数
    // 邻接矩阵更适合vector，快速访问
    vector<vector<int>> adjMatrix;

public:
    // Graph(int V) : V(V), adjMatrix(V, vector<int>(V, 0)) {}
    // 构造函数
    Graph(int V) {
        this->V = V; // 将传入的顶点数赋值给类的成员变量 V
        adjMatrix = vector<vector<int>>(V, vector<int>(V, 0)); // 初始化邻接矩阵
    }

    void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;
        adjMatrix[v][u] = 1; // 对于无向图
    }
    
    void printGraph1() {
        for (int i = 0; i < v; i++) {
            for (int j = 0; j < v; j++) 
                cout << adjMatrix[i][j] << " ";
            cout << endl;
        }
    }
};

int main() {
    Graph g1(4);
    g1.addEdge(0, 1);
    g1.addEdge(0, 2);
    g1.addEdge(1, 2);
    g1.addEdge(2, 3);
    g1.printGraph1();
    
    // 0 1 1 0 
    // 1 0 1 0 
    // 1 1 0 1 
    // 0 0 1 0
    
    return 0;
}
```

#### 2.5 无向图的邻接表建立方法和算法

无向图的邻接表表示每个顶点都有一个与之相关联的列表，列出了所有与该顶点直接相连的其他顶点。

```c++
#include <iostream>
#include <vector>
#include <list>
using namespace std;

class Graph {
    int numVertices; // 顶点数
    // vector 提供了快速的随机访问能力，并且可以在其末尾高效地增加或删除元素  -- adjLists[src] 快速查找
    // list 提供了快速的插入和删除操作（即使在列表中间），但不提供快速的随机访问。  -- push_back 快速添加边
    vector<list<int>> adjLists; // 邻接表，创建的是

public:
    Graph(int vertices) : numVertices(vertices), adjLists(vertices) {}

    // 添加边
    void addEdge(int src, int dest) {
        adjLists[src].push_back(dest);
        adjLists[dest].push_back(src); // 由于是无向图，需要添加双向边
    }

    // 打印图
    void printGraph() {
        for (int i = 0; i < numVertices; i++) {
            cout << "打印图： " << i << ": ";
            // for增强，也是用到了list的特性
            for (int v : adjLists[i]) 
                cout << v << " ";
            cout<<endl;
        }
    }
};

int main() {
    Graph g(4); // 创建一个包含 4 个顶点的图
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);

    g.printGraph(); // 打印图的邻接表
    // 0: 1 2 
    // 1: 0 2 
    // 2: 0 1 3 
    // 3: 2 
    return 0;
}
```

### 3. 图的遍历

#### 3.1 深度优先搜索（DFS）& 广度优先搜索（BFS）

DFS 使用**递归或栈**来实现，从一个起始顶点开始，然后沿着一条路径尽可能深入地访问顶点，直到没有未访问的邻接顶点为止，然后回溯到上一个顶点，继续探索其他路径。

BFS 使用**队列**来实现，遵循先访问邻近顶点的原则。

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

class Graph {
    int V;
    // 邻接表
    vector<vector<int>> adj;

public:
    Graph(int v) : V(v), adj(v) {}

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    int getVertices() {
        return V;
    }

    void DFS(int v, vector<bool>& visited) {
        visited[v] = true;
        cout << v << " ";

        for (int u : adj[v]) 
            if (!visited[u]) 
                DFS(u, visited);
    }

    void BFS(int start) {
        vector<bool> visited(V, false); // 用于跟踪已访问的顶点
        queue<int> q; // 用于存储待访问的顶点

        visited[start] = true; // 标记起始顶点为已访问
        q.push(start); // 将起始顶点放入队列

        while (!q.empty()) { // 当队列不为空时
            int v = q.front(); // 获取队列的前端顶点
            cout << v << " "; // 输出顶点值
            q.pop(); // 从队列中移除顶点

            // 遍历所有与当前顶点相邻的未访问顶点
            for (int u : adj[v]) {
                if (!visited[u]) {
                    visited[u] = true; // 标记为已访问
                    q.push(u); // 将未访问的邻接顶点放入队列
                }
            }
        }
    }
};

int main() {
    Graph g(6);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 4);
    g.addEdge(3, 5);

    vector<bool> visited(g.getVertices(), false);

    cout << "DFS starting from vertex 0:" << endl;
    g.DFS(0, visited);
    // 0 1 3 5 2 4 
    cout << endl;

    visited.assign(g.getVertices(), false);
    
    cout << "BFS starting from vertex 0:" << endl;
    g.BFS(0);
    // 0 1 2 3 4 5

    return 0;
}

```

#### 3. 3非连通图的遍历方法

连通图&非连通图：

- 连通图是指图中的每两个顶点都存在一条路径相连，也就是说，从图中的任意一个顶点出发，都可以到达图中的任意其他顶点。
- 图中存在至少两个顶点集合，这些集合之间没有直接的边相连

非连通图的遍历是遍历图的每个连通分量。对于非连通图，可以使用 DFS 或 BFS 遍历每个连通分量。

```c++
#include <iostream>
#include <vector>
#include <list>
using namespace std;

class Graph {
    int V; // 顶点数
    vector<list<int>> adjLists; // 邻接表

public:
    Graph(int v) : V(v), adjLists(v) {}

    void addEdge(int u, int v) {
        adjLists[u].push_back(v);
        adjLists[v].push_back(u); // 无向图，需要添加反向边
    }

    // 非连通图的DFS遍历
    void DFS() {
        vector<bool> visited(V, false); // 记录顶点是否已访问

        for (int i = 0; i < V; ++i) {
            if (!visited[i]) {
                cout << "Connected Component: ";
                DFSUtil(i, visited); // 从未访问的顶点开始遍历
                cout << endl;
            }
        }
    }

    // 辅助DFS函数
    void DFSUtil(int v, vector<bool>& visited) {
        visited[v] = true;
        cout << v << " ";

        for (int u : adjLists[v]) {
            if (!visited[u]) {
                DFSUtil(u, visited);
            }
        }
    }
};

int main() {
    Graph g(8); // 创建一个包含8个顶点的非连通图

    g.addEdge(0, 1);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(3, 4);
    g.addEdge(5, 6);
    g.addEdge(6, 7);

    cout << "DFS Traversal of the Disconnected Graph:" << endl;
    g.DFS();

// Connected Component: 0 1 2 
// Connected Component: 3 4 
// Connected Component: 5 6 7 

    return 0;
}

```

图的连通分量的求法

#### 3.4 画出无向图的存储结构并确定序列

存储结构就是**邻接矩阵和邻接表**了吧

举例：

```mathematica
   0 -- 1
   |    |
   3 -- 2

邻接矩阵表示：
   0  1  2  3
0  0  1  0  1
1  1  0  1  0
2  0  1  0  1
3  1  0  1  0


邻接表表示：
Vertex 0: 1 3
Vertex 1: 0 2
Vertex 2: 1 3
Vertex 3: 0 2

DFS Sequence: 0 1 2 3
BFS Sequence: 0 1 3 2
```

#### 3.5 图的遍历算法的设计以及应用

BFS：最短路径问题、查找最大流

DFS：检测有向图中是否有环

寻找路径、连通分量、**拓扑排序**、迷宫问题、八皇后问题、数独等。**拓扑排序**

### 4. 最小生成树

#### 4.1 生成树和最小生成树

生成树是包含图中所有顶点的无环子图。最小生成树是权重和最小的生成树。

最小生成树（Minimum Spanning Tree, MST）是一种在图论中非常重要的概念，它在多个领域中都有应用，特别是在那些需要最小化某种成本或连接多个点的场景中。具体应用背景包括：

1. **网络设计**：如电信网络、计算机网络、交通网络设计中，需要以最小的成本连接所有的节点。
2. **城市规划**：设计道路、水管或电缆网络以连接多个地点，同时尽量减少建设成本。
3. **集群分析**：在数据科学中，MST可以用于聚类分析，找出数据点之间的关系。
4. **物理和生物学中的网络系统**：例如在生态学中，研究不同物种之间的互动网络。

#### 4.2 Prim 算法

Prim 算法从任意顶点开始，每次添加与当前生成树距离最短的边。

Prim 算法的基本思想是从一个顶点开始，逐步增加新的边和顶点到已经选择的顶点集合中，直到所有的顶点都被包含在内。在每一步中，它都会选择一条连接已选择顶点和未选择顶点的最小边。

算法步骤：

1. 初始化一个空的树结构（最初只包含一个顶点）和一个优先队列（最小堆），用于存放与已选择顶点相连的边。
2. 将初始顶点的所有邻边加入优先队列中。
3. 当优先队列不为空时，重复以下步骤：
   - 从优先队列中取出权重最小的边。
   - 如果这条边连接的顶点已经在树中，则忽略它；否则，将该边和顶点添加到树中，并将新加入顶点的所有邻边加入优先队列。
4. 当所有顶点都被添加到树中后，算法结束。

算法特点：

- **适用于密集图**：在顶点数量较多的情况下效率较高。
- **贪心算法**：每一步都选择当前可选边中最小的边。
- **简单易实现**：尤其适用于使用**邻接矩阵**表示的图。

```c++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

// 定义一个无穷大的常量，表示距离
const int INF = INT_MAX;

// 找到未包含在最小生成树中的顶点中关键值最小的顶点
int minKey(const vector<int>& key, const vector<bool>& mstSet, int V) {
    int min = INF, min_index;
    for (int v = 0; v < V; v++) {
        if (!mstSet[v] && key[v] < min) {
            min = key[v];
            min_index = v;
        }
    }
    return min_index;
}

// 输出最小生成树的边
void printMST(const vector<int>& parent, const vector<vector<int>>& graph, int V) {
    cout << "Edge \tWeight" << endl;
    for (int i = 1; i < V; i++) {
        cout << parent[i] << " - " << i << "\t" << graph[i][parent[i]] << endl;
    }
}

// 使用Prim算法构建最小生成树
void primMST(const vector<vector<int>>& graph, int V) {
    vector<int> parent(V);
    vector<int> key(V, INF); // 用于存储每个顶点到最小生成树的距离
    vector<bool> mstSet(V, false);

    // 选择第一个顶点作为起始顶点
    key[0] = 0;
    parent[0] = -1;

    // 逐步构建最小生成树
    for (int count = 0; count < V - 1; count++) {
        int u = minKey(key, mstSet, V);
        mstSet[u] = true;

        // 更新与u相邻的顶点的距离和父节点
        for (int v = 0; v < V; v++) {
            if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }
    // 输出最小生成树
    printMST(parent, graph, V);
}

int main() {
    int V = 5; // 顶点数
    vector<vector<int>> graph = {
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 0, 7},
        {6, 8, 0, 0, 9},
        {0, 5, 7, 9, 0}
    };
    primMST(graph, V);
    return 0;
}

```

#### 4.3 克鲁斯卡尔算法

克鲁斯卡尔算法从边的角度出发，选择最小权重的边，同时保证不形成环，直到构成一个最小生成树。

克鲁斯卡尔算法的核心思想是按照边的权重（从小到大）顺序选择边，以构造最小生成树。在选择边的过程中，算法确保所选的边不会形成环。

算法步骤

1. **初始化**：将图中的所有边按权重排序。
2. **创建集合**：为每个顶点创建一个集合，用于判断是否形成环。
3. **选择边**：从权重最小的边开始，依次考虑每条边：
   - 如果当前边连接的两个顶点属于不同的集合，则选择这条边，并合并两个集合（即加入当前边不会形成环）。
   - 如果当前边连接的两个顶点属于同一集合，则忽略这条边（即加入当前边会形成环）。
4. **重复上述步骤**，直到选择了 `V-1` 条边，其中 `V` 是图中顶点的数量。

特点

- **适用于边比较稀疏的图**：在边数相对较少的情况下效率较高。
- **边为主导**：算法的主要操作是对边进行排序和选择。
- **不依赖起始顶点**：与 Prim 算法不同，克鲁斯卡尔算法不从特定的顶点开始。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 边的数据结构
struct Edge {
    int src, dest, weight;
};

// 图的数据结构
class Graph {
public:
    int V, E;
    vector<Edge> edges;

    Graph(int vertices, int edgesCount) : V(vertices), E(edgesCount) {
        edges.resize(E);
    }

    void addEdge(int src, int dest, int weight) {
        edges.push_back({src, dest, weight});
    }

    // 克鲁斯卡尔算法
    void kruskalMST();
};

// 用于并查集的数据结构
class DisjointSet {
public:
    vector<int> parent, rank;

    DisjointSet(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    // 查找根节点
    int find(int v) {
        if (v != parent[v]) {
            parent[v] = find(parent[v]);
        }
        return parent[v];
    }

    // 合并两个集合
    void unionSets(int u, int v) {
        int rootU = find(u);
        int rootV = find(v);
        if (rootU != rootV) {
            if (rank[rootU] < rank[rootV]) {
                parent[rootU] = rootV;
            } else if (rank[rootU] > rank[rootV]) {
                parent[rootV] = rootU;
            } else {
                parent[rootV] = rootU;
                rank[rootU]++;
            }
        }
    }
};

// 按边的权重进行排序的比较函数
bool compareEdges(const Edge& a, const Edge& b) {
    return a.weight < b.weight;
}

// 克鲁斯卡尔算法的实现
void Graph::kruskalMST() {
    vector<Edge> result;
    int i = 0;
    int e = 0;

    // 按边的权重升序排序
    sort(edges.begin(), edges.end(), compareEdges);

    DisjointSet ds(V);

    // 构建最小生成树
    while (e < V - 1 && i < E) {
        Edge nextEdge = edges[i++];
        int rootSrc = ds.find(nextEdge.src);
        int rootDest = ds.find(nextEdge.dest);

        // 如果不会形成环，将边添加到最小生成树中
        if (rootSrc != rootDest) {
            result.push_back(nextEdge);
            ds.unionSets(rootSrc, rootDest);
            e++;
        }
    }

    // 输出最小生成树的边
    cout << "Edges in MST:" << endl;
    for (const Edge& edge : result) {
        cout << edge.src << " - " << edge.dest << " : " << edge.weight << endl;
    }
}

int main() {
    int V = 4; // 顶点数
    int E = 5; // 边数
    Graph graph(V, E);

    // 添加边
    graph.addEdge(0, 1, 10);
    graph.addEdge(0, 2, 6);
    graph.addEdge(0, 3, 5);
    graph.addEdge(1, 3, 15);
    graph.addEdge(2, 3, 4);

    // 执行克鲁斯卡尔算法
    graph.kruskalMST();

    return 0;
}
```

### 5. 拓扑排序

#### 5.1 拓扑排序的概念和背景

拓扑排序是对有向无环图（Directed Acyclic Graph, DAG）的顶点进行排序，使得对于任何一条有向边 `u -> v`，`u` 都在 `v`
之前。拓扑排序不是唯一的。

拓扑排序在以下领域中应用广泛：

1. **任务调度**：在任务需要按特定顺序完成的场景中，如编译系统中源代码到目标代码的转换，构建系统中的任务依赖。
2. **课程规划**：学生的课程安排，其中某些课程有前置课程要求。
3. **项目管理**：在项目管理中，特别是在确定项目计划的不同阶段和活动的顺序时。

#### 5.2 拓扑排序的步骤和算法设计过程

拓扑排序是对有向无环图（DAG）的所有顶点的线性排序，使得对于每条有向边 uv，顶点 u 在顶点 v 之前。

```c++
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

class Graph {
public:
    int V; // 顶点数
    vector<vector<int>> adj; // 邻接表

    Graph(int vertices) : V(vertices) {
        adj.resize(V);
    }

    // 添加有向边
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }

    // 深度优先搜索的拓扑排序函数
    // 对这个顶点进行DFS，如果它有前驱顶点，那么DFS将继续向前驱顶点进行递归访问。这意味着在DFS的过程中，我们会访问到当前顶点的所有前驱顶点，这些前驱顶点的入度将逐渐减少。
    void topologicalSortDFS(int v, vector<bool>& visited, stack<int>& result) {
        visited[v] = true;

        for (int neighbor : adj[v]) 
            if (!visited[neighbor]) 
                topologicalSortDFS(neighbor, visited, result);

        result.push(v); // 在回溯时将顶点添加到结果栈中，这个时候传入的是周围节点都被访问过的点，这个点的特点就是其他点都是它的前驱节点，它本身不是任何节点的前驱节点了（不然可以继续往后推，所以为什么要用stack，因为先进后出，先进去的是前驱节点越多的点，这种点就要越往后排序
    }

    // 执行拓扑排序
    void topologicalSort() {
        stack<int> result; // 存储拓扑排序结果的栈
        vector<bool> visited(V, false); // 用于标记顶点是否已访问

        // 对每个未访问的顶点执行DFS
        for (int i = 0; i < V; i++) 
            if (!visited[i]) 
                topologicalSortDFS(i, visited, result);


        // 打印拓扑排序结果
        cout << "Topological Sort Order:" << endl;
        while (!result.empty()) {
            cout << result.top() << " ";
            result.pop();
        }
        cout << endl;
    }
};

int main() {
    int V = 6; // 顶点数
    Graph g(V);

    // 添加有向边
    g.addEdge(5, 2);
    g.addEdge(5, 0);
    g.addEdge(4, 0);
    g.addEdge(4, 1);
    g.addEdge(2, 3);
    g.addEdge(3, 1);

    // 执行拓扑排序
    g.topologicalSort();

    return 0;
}

```

流程：

```c++
A ------> B
|         |
v         v
C ------> D

选择节点 A 进行DFS：
   访问 A，标记为已访问。
   访问 A 的邻接节点 B：
      访问 B，标记为已访问。
      访问 B 的邻接节点 D：
         访问 D，标记为已访问。
         将 D 加入拓扑排序列表。
      将 B 加入拓扑排序列表。
访问 A 的邻接节点 C：
   访问 C，标记为已访问。
   注意：C 的邻接节点 D 已被访问。
   将 C 加入拓扑排序列表。
将 A 加入拓扑排序列表。
最终的拓扑排序列表是：A, C, B, D。这表示任务的执行顺序是 A、C、B、D。 
```

### 6. 最短路径

#### 6.1最短路径基本步骤

1. **问题建模：** 将实际问题转化为图的形式，其中节点表示元素或位置，边表示可达关系。
2. **图的表示：** 选择合适的图表示方法，如邻接矩阵或邻接表。
3. **初始化数据结构：** 创建数据结构来存储有关节点的信息，包括起始节点到各个节点的距离估计，已访问标记，以及路径记录等信息。通常使用队列、堆（优先队列）或其他数据结构来管理搜索过程。
4. **选择算法：** 根据问题的特点和要求选择合适的最短路径算法。常见的算法包括：
   - Dijkstra 算法：用于计算单源最短路径，适用于边的权重为非负数的图。
   - Floyd-Warshall 算法：用于计算所有节点对之间的最短路径，适用于边的权重可以为负数的图。
5. **开始搜索：** 从起始节点开始搜索最短路径，探索相邻节点并更新距离估计。
6. **更新距离：** 在搜索过程中，通过找到更短的路径来更新节点的距离估计。
7. **路径回溯：** 如果找到目标节点，回溯路径以获得最短路径。
8. **输出结果：** 输出最短路径的距离和路径。

#### 6.2 最短路径算法设计

最短路径问题是找出图中两个顶点之间的最短路径。这里是两种常见的最短路径算法的设计思路：

1. **Dijkstra 算法**：适用于加权图中的单源最短路径问题。算法思路是不断选择未访问的最近顶点，并更新其邻居的最短路径。

   ```c++
   #include <iostream>
   #include <vector>
   #include <limits>
   
   using namespace std;
   
   class Graph {
   public:
       int V; // 顶点数
       vector<vector<int>> adj; // 邻接矩阵
   
       Graph(int vertices) : V(vertices) {
           adj.resize(V, vector<int>(V, 0));
       }
   
       // 添加有向边
       void addEdge(int u, int v, int weight) {
           adj[u][v] = weight;
       }
   
       // Dijkstra算法求单源最短路径
       void dijkstra(int src) {
           vector<int> dist(V, numeric_limits<int>::max());
           vector<bool> visited(V, false);
   
           dist[src] = 0;
   
           for (int count = 0; count < V - 1; count++) {
               int u = minDistance(dist, visited);
               visited[u] = true;
   
               for (int v = 0; v < V; v++) 
                   if (!visited[v] && adj[u][v] && dist[u] != numeric_limits<int>::max() && dist[u] + adj[u][v] < dist[v]) 
                       dist[v] = dist[u] + adj[u][v];
           }
   
           // 输出最短路径
           cout << "Vertex \t Distance from Source" << endl;
           for (int i = 0; i < V; i++) 
               cout << i << " \t " << dist[i] << endl;
       }
   
       // 寻找距离最小的未访问节点
       int minDistance(const vector<int>& dist, const vector<bool>& visited) {
           int minDist = numeric_limits<int>::max();
           int minIndex = -1;
   
           for (int v = 0; v < V; v++) 
               if (!visited[v] && dist[v] <= minDist) 
                   minDist = dist[v];
                   minIndex = v;
   
           return minIndex;
       }
   };
   
   int main() {
       int V = 5; // 顶点数
       Graph g(V);
   
       g.addEdge(0, 1, 2);
       g.addEdge(0, 2, 4);
       g.addEdge(1, 2, 1);
       g.addEdge(1, 3, 7);
       g.addEdge(2, 4, 3);
       g.addEdge(3, 4, 1);
   
       g.dijkstra(0);
   
       return 0;
   }
   ```

2. **Floyd-Warshall 算法**：用于计算图中所有顶点对之间的最短路径。它使用动态规划的方法，考虑每个顶点作为中间顶点的情况。

   ```c++
   #include <iostream>
   #include <vector>
   #include <limits>
   
   using namespace std;
   
   class Graph {
   public:
       int V; // 顶点数
       vector<vector<int>> adj; // 邻接矩阵
   
       Graph(int vertices) : V(vertices) {
           adj.resize(V, vector<int>(V, numeric_limits<int>::max())); // 初始化为无穷大
           for (int i = 0; i < V; i++) 
               adj[i][i] = 0; // 对角线上的元素初始化为0
       }
   
       // 添加有向边
       void addEdge(int u, int v, int weight) {
           adj[u][v] = weight;
       }
   
       // Floyd-Warshall算法求所有节点对之间的最短路径
       void floydWarshall() {
           vector<vector<int>> dist = adj;
   
           for (int k = 0; k < V; k++) 
               for (int i = 0; i < V; i++) 
                   for (int j = 0; j < V; j++) 
                       if (dist[i][k] != numeric_limits<int>::max() && dist[k][j] != numeric_limits<int>::max() && dist[i][k] + dist[k][j] < dist[i][j]) 
                           dist[i][j] = dist[i][k] + dist[k][j];
   
           // 输出最短路径
           cout << "Shortest Path Matrix:" << endl;
           for (int i = 0; i < V; i++) 
               for (int j = 0; j < V; j++) 
                   if (dist[i][j] == numeric_limits<int>::max()) 
                       cout << "INF ";
                    else 
                       cout << dist[i][j] << " ";
               cout << endl;
       }
   };
   
   int main() {
       int V = 5; // 顶点数
       Graph g(V);
   
       g.addEdge(0, 1, 2);
       g.addEdge(0, 2, 4);
       g.addEdge(1, 2, 1);
       g.addEdge(1, 3, 7);
       g.addEdge(2, 4, 3);
       g.addEdge(3, 4, 1);
   
       g.floydWarshall();
   
       return 0;
   }
   ```

## 22年期末试卷

### 应用解答题

1. 最大堆

```c++
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int main() {
    // 初始化最大堆
    priority_queue<string> maxHeap;

    // 给定的单词列表
    vector<string> words = {"int", "break", "else", "switch", "double", "case","char", "float", "for", "do", "if", "while"};

    // 将单词插入最大堆
    for (const string& word : words) {
        maxHeap.push(word);
    }

    // 输出最大堆中的元素
    cout << "Max Heap elements (in descending order):" << endl;
    while (!maxHeap.empty()) {
        cout << maxHeap.top() << " ";
        maxHeap.pop();
    }

    // "while", "switch", "float", "double", "else", "do", "for", "if", "int", "char", "case", "break"
    return 0;
}

```

TODO：这道题好像不太对

![image-20231218193305523](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231218193305523.png)

（1） 编号 = k * n + i

```mathematica
        0
       / \
      1   2
     / \ / \
    3  4 5  6
```

- 对于节点 1，它的第 1 个子节点是 3，计算方法是：2 * 1 + 1 = 3。
- 对于节点 2，它的第 2 个子节点是 6，计算方法是：2 * 2 + 2 = 6。

（2） 一个节点有右兄弟的条件是它不是其父节点的最后一个子节点，即n % k != k - 1

继续使用上面的二叉树例子：

- 节点 3（编号为 3）的计算方法是：3 % 2 != 1，所以它没有右兄弟。
- 节点 5（编号为 5）的计算方法是：5 % 2 != 1，所以它有右兄弟（节点 6）。

（3） 深度为 h 的满 k 叉树的节点总数 n 可以通过求解等比数列的和来得到：n = 1 + k + k^2 + k^3 + ... + k^(h-1)

​ 通过等比数列的和公式推导出来：h = logk((n-1) * (k-1) + 1)

继续使用上面的二叉树例子：

- 深度 h = 3，节点总数 n 计算为：1 + 2 + 2^2 = 7。
- 如果我们知道 n = 7，那么深度 h 的计算方法是：h = log2((7-1)*(2-1) + 1) = 3。

### 算法设计题

![image-20231218190742229](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231218190742229.png)

```c++
#include <iostream>
#include <queue>
#include <vector>
#include <string>
using namespace std;

// 1：定义哈夫曼树存储结构
struct HuffmanNode {
    char data; // 存储字符
    unsigned freq; // 字符出现的频率
    HuffmanNode *left, *right;

    HuffmanNode(char data, unsigned freq) : data(data), freq(freq), left(nullptr), right(nullptr) {}
};

// 比较函数，用于优先队列
struct Compare {
    bool operator()(HuffmanNode* l, HuffmanNode* r) {
        return l->freq > r->freq;
    }
};


// 2. 构建哈夫曼树
HuffmanNode* buildHuffmanTree(vector<char>& data, vector<unsigned>& freq, int size) {
    priority_queue<HuffmanNode*, vector<HuffmanNode*>, Compare> minHeap;

    for (int i = 0; i < size; ++i) {
        minHeap.push(new HuffmanNode(data[i], freq[i]));
    }

    while (minHeap.size() != 1) {
        HuffmanNode* left = minHeap.top();
        minHeap.pop();

        HuffmanNode* right = minHeap.top();
        minHeap.pop();

        HuffmanNode* top = new HuffmanNode('$', left->freq + right->freq);
        top->left = left;
        top->right = right;

        minHeap.push(top);
    }

    return minHeap.top();
}

//  3: 遍历哈夫曼树并按编码长度排序输出
void printCodes(HuffmanNode* root, string str, vector<pair<string, char>>& codes) {
    if (!root) return;

    if (root->data != '$') {
        codes.push_back(make_pair(str, root->data));
    }

    printCodes(root->left, str + "0", codes);
    printCodes(root->right, str + "1", codes);
}

bool compareByLength(const pair<string, char>& a, const pair<string, char>& b) {
    return a.first.length() > b.first.length();
}

void printHuffmanCodes(vector<char>& data, vector<unsigned>& freq, int size) {
    HuffmanNode* root = buildHuffmanTree(data, freq, size);
    vector<pair<string, char>> codes;
    printCodes(root, "", codes);

    sort(codes.begin(), codes.end(), compareByLength);

    // auto，自动根据codes 容器中元素的类型推断 code 的类型，方便
    for (auto& code : codes) {
        cout << code.second << ": " << code.first << endl;
    }
}


// 4: 主函数
int main() {
    vector<char> data = {'a', 'b', 'c', 'd', 'e', 'f'};
    vector<unsigned> freq = {5, 9, 12, 13, 16, 45};

    int size = data.size();
    printHuffmanCodes(data, freq, size);
    
    return 0;
}

```

